<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Programming Guides on Protocol Buffers Documentation</title><link>https://protobuf.dev/programming-guides/</link><description>Recent content in Programming Guides on Protocol Buffers Documentation</description><generator>Hugo</generator><language>en</language><atom:link href="https://protobuf.dev/programming-guides/index.xml" rel="self" type="application/rss+xml"/><item><title>Language Guide (editions)</title><link>https://protobuf.dev/programming-guides/editions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/editions/</guid><description>This guide describes how to use the protocol buffer language to structure your protocol buffer data, including .proto file syntax and how to generate data access classes from your .proto files. It covers edition 2023 of the protocol buffers language. For information about how editions differ from proto2 and proto3 conceptually, see Protobuf Editions Overview.
For information on the proto2 syntax, see the Proto2 Language Guide.
For information on proto3 syntax, see the Proto3 Language Guide.</description></item><item><title>Language Guide (proto 2)</title><link>https://protobuf.dev/programming-guides/proto2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/proto2/</guid><description>This guide describes how to use the protocol buffer language to structure your protocol buffer data, including .proto file syntax and how to generate data access classes from your .proto files. It covers the proto2 revision of the protocol buffers language.
For information on editions syntax, see the Protobuf Editions Language Guide.
For information on proto3 syntax, see the Proto3 Language Guide.
This is a reference guide – for a step by step example that uses many of the features described in this document, see the tutorial for your chosen language.</description></item><item><title>Language Guide (proto 3)</title><link>https://protobuf.dev/programming-guides/proto3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/proto3/</guid><description>This guide describes how to use the protocol buffer language to structure your protocol buffer data, including .proto file syntax and how to generate data access classes from your .proto files. It covers the proto3 revision of the protocol buffers language.
For information on editions syntax, see the Protobuf Editions Language Guide.
For information on the proto2 syntax, see the Proto2 Language Guide.
This is a reference guide – for a step by step example that uses many of the features described in this document, see the tutorial for your chosen language.</description></item><item><title>Proto Limits</title><link>https://protobuf.dev/programming-guides/proto-limits/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/proto-limits/</guid><description>This topic documents the limits to the number of supported elements (fields, enum values, and so on) in proto schemas.
This information is a collection of discovered limitations by many engineers, but is not exhaustive and may be incorrect/outdated in some areas. As you discover limitations in your work, contribute those to this document to help others.
Number of Fields Message with only singular proto fields (such as Boolean):
~2100 fields (proto2) ~3100 (proto3 without using optional fields) Empty message extended by singular fields (such as Boolean):</description></item><item><title>Style Guide</title><link>https://protobuf.dev/programming-guides/style/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/style/</guid><description>This document provides a style guide for .proto files. By following these conventions, you&amp;rsquo;ll make your protocol buffer message definitions and their corresponding classes consistent and easy to read.
Note that protocol buffer style has evolved over time, so it is likely that you will see .proto files written in different conventions or styles. Respect the existing style when you modify these files. Consistency is key. However, it is best to adopt the current best style when you are creating a new .</description></item><item><title>Enum Behavior</title><link>https://protobuf.dev/programming-guides/enum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/enum/</guid><description>Enums behave differently in different language libraries. This topic covers the different behaviors as well as the plans to move protobufs to a state where they are consistent across all languages. If you&amp;rsquo;re looking for information on how to use enums in general, see the corresponding sections in the proto2 and proto3 language guide topics.
Definitions Enums have two distinct flavors (open and closed). They behave identically except in their handling of unknown values.</description></item><item><title>Encoding</title><link>https://protobuf.dev/programming-guides/encoding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/encoding/</guid><description>This document describes the protocol buffer wire format, which defines the details of how your message is sent on the wire and how much space it consumes on disk. You probably don&amp;rsquo;t need to understand this to use protocol buffers in your application, but it&amp;rsquo;s useful information for doing optimizations.
If you already know the concepts but want a reference, skip to the Condensed reference card section.
Protoscope is a very simple language for describing snippets of the low-level wire format, which we&amp;rsquo;ll use to provide a visual reference for the encoding of various messages.</description></item><item><title>ProtoJSON Format</title><link>https://protobuf.dev/programming-guides/json/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/json/</guid><description>Protobuf supports a canonical encoding in JSON, making it easier to share data with systems that do not support the standard protobuf binary wire format.
ProtoJSON Format is not as efficient as protobuf wire format. The converter uses more CPU to encode and decode messages and (except in rare cases) encoded messages consume more space. Furthermore, ProtoJSON format puts your field and enum value names into encoded messages making it much harder to change those names later.</description></item><item><title>Techniques</title><link>https://protobuf.dev/programming-guides/techniques/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/techniques/</guid><description>You can also send design and usage questions to the Protocol Buffers discussion group.
Common Filename Suffixes It is fairly common to write messages to files in several different formats. We recommend using the following file extensions for these files.
Content Extension Text Format .txtpb Wire Format .binpb JSON Format .json For Text Format specifically, .textproto is also fairly common, but we recommend .txtpb for its brevity.
Streaming Multiple Messages If you want to write multiple messages to a single file or stream, it is up to you to keep track of where one message ends and the next begins.</description></item><item><title>Third-Party Add-ons</title><link>https://protobuf.dev/programming-guides/addons/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/addons/</guid><description>Many open source projects seek to add useful functionality on top of Protocol Buffers. For a list of links to projects we know about, see the third-party add-ons wiki page.</description></item><item><title>Extension Declarations</title><link>https://protobuf.dev/programming-guides/extension_declarations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/extension_declarations/</guid><description>Introduction This page describes in detail what extension declarations are, why we need them, and how we use them.
NOTE: Proto3 does not support extensions (except for declaring custom options). Extensions are fully supported in proto2 and editions though.
If you need an introduction to extensions, read this extensions guide
Motivation Extension declarations aim to strike a happy medium between regular fields and extensions. Like extensions, they avoid creating a dependency on the message type of the field, which therefore results in a leaner build graph and smaller binaries in environments where unused messages are difficult or impossible to strip.</description></item><item><title>Application Note: Field Presence</title><link>https://protobuf.dev/programming-guides/field_presence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/field_presence/</guid><description>Background Field presence is the notion of whether a protobuf field has a value. There are two different manifestations of presence for protobufs: implicit presence, where the generated message API stores field values (only), and explicit presence, where the API also stores whether or not a field has been set.
Historically, proto2 has mostly followed explicit presence, while proto3 exposes only implicit presence semantics. Singular proto3 fields of basic types (numeric, string, bytes, and enums) which are defined with the optional label have explicit presence, like proto2 (this feature is enabled by default as release 3.</description></item><item><title>Proto Serialization Is Not Canonical</title><link>https://protobuf.dev/programming-guides/serialization-not-canonical/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/serialization-not-canonical/</guid><description>Many people want a serialized proto to canonically represent the contents of that proto. Use cases include:
using a serialized proto as a key in a hash table taking a fingerprint or checksum of a serialized proto comparing serialized payloads as a way of checking message equality Unfortunately, protobuf serialization is not (and cannot be) canonical. There are a few notable exceptions, such as MapReduce, but in general you should generally think of proto serialization as unstable.</description></item><item><title>Deserializing Debug Proto Representations</title><link>https://protobuf.dev/programming-guides/deserialize-debug/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/deserialize-debug/</guid><description>From version 29.x, DebugString APIs (proto2::DebugString, proto2::ShortDebugString, proto2::Utf8DebugString) are deprecated. DebugString users should migrate to some Abseil string functions (such as absl::StrCat, absl::StrFormat, absl::StrAppend, AND absl::Substitute), Abseil logging API, and some Protobuf APIs (proto2::ShortFormat, proto2::Utf8Format) to automatically convert proto arguments into a new debugging format .
Unlike the Protobuf DebugString output format, the new debugging format automatically redacts sensitive fields by replacing their values with the string &amp;ldquo;[REDACTED]&amp;rdquo; (without the quotation marks).</description></item><item><title>No Nullable Setters/Getters Support</title><link>https://protobuf.dev/programming-guides/nullable-getters-setters/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/nullable-getters-setters/</guid><description>We have heard feedback that some folks would like protobuf to support nullable getters/setters in their null-friendly language of choice (particularly Kotlin, C#, and Rust). While this does seem to be a helpful feature for folks using those languages, the design choice has tradeoffs which have led to the Protobuf team choosing not to implement them.
The biggest reason not to have nullable fields is the intended behavior of default values specified in a .</description></item><item><title>Proto Best Practices</title><link>https://protobuf.dev/programming-guides/best-practices/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/best-practices/</guid><description>Best practices content for defining and using protos exists in the following topics:
Proto Best Practices API Best Practices 1-1-1 Rule</description></item><item><title>Proto Best Practices</title><link>https://protobuf.dev/programming-guides/dos-donts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/dos-donts/</guid><description>Clients and servers are never updated at exactly the same time - even when you try to update them at the same time. One or the other may get rolled back. Don’t assume that you can make a breaking change and it&amp;rsquo;ll be okay because the client and server are in sync.
Don&amp;rsquo;t Re-use a Tag Number Never re-use a tag number. It messes up deserialization. Even if you think no one is using the field, don’t re-use a tag number.</description></item><item><title>API Best Practices</title><link>https://protobuf.dev/programming-guides/api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/api/</guid><description>Updated for proto3. Patches welcome!
This doc is a complement to Proto Best Practices. It&amp;rsquo;s not a prescription for Java/C++/Go and other APIs.
If you see a proto straying from these guidelines in a code review, point the author to this topic and help spread the word.
Note These guidelines are just that and many have documented exceptions. For example, if you&amp;rsquo;re writing a performance-critical backend, you might want to sacrifice flexibility or safety for speed.</description></item><item><title>1-1-1 Best Practice</title><link>https://protobuf.dev/programming-guides/1-1-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/1-1-1/</guid><description>The 1-1-1 best practice is to keep every proto_library and .proto file as small as is reasonable, with the ideal being:
One proto_library build rule One source .proto file One top-level entity (message, enum, or extension) Having the fewest number of message, enum, extension, and services as you reasonably can makes refactoring easier. Moving files when they&amp;rsquo;re separated is much easier than extracting messages from a file with other messages.</description></item></channel></rss>