<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Programming Guides on Protocol Buffers Documentation</title><link>https://protobuf.dev/programming-guides/</link><description>Recent content in Programming Guides on Protocol Buffers Documentation</description><generator>Hugo</generator><language>en</language><atom:link href="https://protobuf.dev/programming-guides/index.xml" rel="self" type="application/rss+xml"/><item><title>Language Guide (editions)</title><link>https://protobuf.dev/programming-guides/editions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/editions/</guid><description>This guide describes how to use the protocol buffer language to structure your protocol buffer data, including .proto file syntax and how to generate data access classes from your .proto files. It covers edition 2023 of the protocol buffers language. For information about how editions differ from proto2 and proto3 conceptually, see Protobuf Editions Overview.
For information on the proto2 syntax, see the Proto2 Language Guide.
For information on proto3 syntax, see the Proto3 Language Guide.</description></item><item><title>Language Guide (proto 2)</title><link>https://protobuf.dev/programming-guides/proto2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/proto2/</guid><description>This guide describes how to use the protocol buffer language to structure your protocol buffer data, including .proto file syntax and how to generate data access classes from your .proto files. It covers the proto2 revision of the protocol buffers language.
For information on editions syntax, see the Protobuf Editions Language Guide.
For information on proto3 syntax, see the Proto3 Language Guide.
This is a reference guide – for a step by step example that uses many of the features described in this document, see the tutorial for your chosen language.</description></item><item><title>Language Guide (proto 3)</title><link>https://protobuf.dev/programming-guides/proto3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/proto3/</guid><description>This guide describes how to use the protocol buffer language to structure your protocol buffer data, including .proto file syntax and how to generate data access classes from your .proto files. It covers the proto3 revision of the protocol buffers language.
For information on editions syntax, see the Protobuf Editions Language Guide.
For information on the proto2 syntax, see the Proto2 Language Guide.
This is a reference guide – for a step by step example that uses many of the features described in this document, see the tutorial for your chosen language.</description></item><item><title>Proto Limits</title><link>https://protobuf.dev/programming-guides/proto-limits/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/proto-limits/</guid><description>This topic documents the limits to the number of supported elements (fields, enum values, and so on) in proto schemas.
This information is a collection of discovered limitations by many engineers, but is not exhaustive and may be incorrect/outdated in some areas. As you discover limitations in your work, contribute those to this document to help others.
Number of Fields Message with only singular proto fields (such as Boolean):
~2100 fields (proto2) ~3100 (proto3 without using optional fields) Empty message extended by singular fields (such as Boolean):</description></item><item><title>Style Guide</title><link>https://protobuf.dev/programming-guides/style/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/style/</guid><description>This document provides a style guide for .proto files. By following these conventions, you&amp;rsquo;ll make your protocol buffer message definitions and their corresponding classes consistent and easy to read.
Standard File Formatting Keep the line length to 80 characters. Use an indent of 2 spaces. Prefer the use of double quotes for strings. File Structure Files should be named lower_snake_case.proto.
All files should be ordered in the following manner:
License header (if applicable) File overview Syntax Package Imports (sorted) File options Everything else Identifier naming styles Protobuf identifiers use one of the following naming styles:</description></item><item><title>Enum Behavior</title><link>https://protobuf.dev/programming-guides/enum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/enum/</guid><description>Enums behave differently in different language libraries. This topic covers the different behaviors as well as the plans to move protobufs to a state where they are consistent across all languages. If you&amp;rsquo;re looking for information on how to use enums in general, see the corresponding sections in the proto2 and proto3 language guide topics.
Definitions Enums have two distinct flavors (open and closed). They behave identically except in their handling of unknown values.</description></item><item><title>Encoding</title><link>https://protobuf.dev/programming-guides/encoding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/encoding/</guid><description>This document describes the protocol buffer wire format, which defines the details of how your message is sent on the wire and how much space it consumes on disk. You probably don&amp;rsquo;t need to understand this to use protocol buffers in your application, but it&amp;rsquo;s useful information for doing optimizations.
If you already know the concepts but want a reference, skip to the Condensed reference card section.
Protoscope is a very simple language for describing snippets of the low-level wire format, which we&amp;rsquo;ll use to provide a visual reference for the encoding of various messages.</description></item><item><title>ProtoJSON Format</title><link>https://protobuf.dev/programming-guides/json/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/json/</guid><description>Protobuf supports a canonical encoding in JSON, making it easier to share data with systems that do not support the standard protobuf binary wire format.
ProtoJSON Format is not as efficient as protobuf wire format. The converter uses more CPU to encode and decode messages and (except in rare cases) encoded messages consume more space. Furthermore, ProtoJSON format puts your field and enum value names into encoded messages making it much harder to change those names later.</description></item><item><title>Techniques</title><link>https://protobuf.dev/programming-guides/techniques/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/techniques/</guid><description>You can also send design and usage questions to the Protocol Buffers discussion group.
Common Filename Suffixes It is fairly common to write messages to files in several different formats. We recommend using the following file extensions for these files.
Content Extension Text Format .txtpb Wire Format .binpb JSON Format .json For Text Format specifically, .textproto is also fairly common, but we recommend .txtpb for its brevity.
Streaming Multiple Messages If you want to write multiple messages to a single file or stream, it is up to you to keep track of where one message ends and the next begins.</description></item><item><title>Third-Party Add-ons</title><link>https://protobuf.dev/programming-guides/addons/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/addons/</guid><description>Many open source projects seek to add useful functionality on top of Protocol Buffers. For a list of links to projects we know about, see the third-party add-ons wiki page.</description></item><item><title>Extension Declarations</title><link>https://protobuf.dev/programming-guides/extension_declarations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/extension_declarations/</guid><description>Introduction This page describes in detail what extension declarations are, why we need them, and how we use them.
Note Proto3 does not support extensions (except for declaring custom options). Extensions are fully supported in proto2 and editions though. If you need an introduction to extensions, read this extensions guide
Motivation Extension declarations aim to strike a happy medium between regular fields and extensions. Like extensions, they avoid creating a dependency on the message type of the field, which therefore results in a leaner build graph and smaller binaries in environments where unused messages are difficult or impossible to strip.</description></item><item><title>Application Note: Field Presence</title><link>https://protobuf.dev/programming-guides/field_presence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/field_presence/</guid><description>Background Field presence is the notion of whether a protobuf field has a value. There are two different manifestations of presence for protobufs: implicit presence, where the generated message API stores field values (only), and explicit presence, where the API also stores whether or not a field has been set.
Note We recommend always adding the optional label for proto3 basic types. This provides a smoother path to editions, which uses explicit presence by default.</description></item><item><title>Proto Serialization Is Not Canonical</title><link>https://protobuf.dev/programming-guides/serialization-not-canonical/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/serialization-not-canonical/</guid><description>Many people want a serialized proto to canonically represent the contents of that proto. Use cases include:
using a serialized proto as a key in a hash table taking a fingerprint or checksum of a serialized proto comparing serialized payloads as a way of checking message equality Unfortunately, protobuf serialization is not (and cannot be) canonical. There are a few notable exceptions, such as MapReduce, but in general you should generally think of proto serialization as unstable.</description></item><item><title>Deserializing Debug Proto Representations</title><link>https://protobuf.dev/programming-guides/deserialize-debug/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/deserialize-debug/</guid><description>From version 30.x, Protobuf DebugString APIs (Message::DebugString, Message::ShortDebugString, Message::Utf8DebugString), additional Protobuf APIs (proto2::ShortFormat, proto2::Utf8Format), Abseil string functions (such as absl::StrCat, absl::StrFormat, absl::StrAppend, and absl::Substitute), and Abseil logging API will begin to automatically convert proto arguments into a new debugging format . See the related announcement here.
Unlike the Protobuf DebugString output format, the new debugging format automatically redacts sensitive fields by replacing their values with the string &amp;ldquo;[REDACTED]&amp;rdquo; (without the quotation marks).</description></item></channel></rss>