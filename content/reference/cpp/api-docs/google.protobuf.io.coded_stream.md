+++
title = "coded_stream.h"
toc_hide = "true"
linkTitle = "C++"
description = "This section contains reference documentation for working with protocol buffer classes in C++."
type = "docs"
+++

<p><code>#include &lt;google/protobuf/io/coded_stream.h&gt;<br>namespace <a href="#google.protobuf.io">google::protobuf::io</a></code></p><p>This file contains the <a href='#CodedInputStream'>CodedInputStream</a> and <a href='#CodedOutputStream'>CodedOutputStream</a> classes, which wrap a <a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>ZeroCopyInputStream</a> or <a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a>, respectively, and allow you to read or write individual pieces of data in various formats. </p><p>In particular, these implement the varint encoding for integers, a simple variable-length encoding in which smaller numbers take fewer bytes.</p>

<p>Typically these classes will only be used internally by the protocol buffer library in order to encode and decode protocol buffers. Clients of the library only need to know about this class if they wish to write custom message parsing or serialization procedures.</p>

<p><a href='#CodedOutputStream'>CodedOutputStream</a> example: </p>

<pre>// Write some data to "myfile".  First we write a 4-byte "magic number"
// to identify the file type, then write a length-delimited string.  The
// string is composed of a varint giving the length followed by the raw
// bytes.
int fd = open("myfile", O_CREAT | O_WRONLY);
ZeroCopyOutputStream* raw_output = new FileOutputStream(fd);
CodedOutputStream* coded_output = new CodedOutputStream(raw_output);

int magic_number = 1234;
char text[[]] = "Hello world!";
coded_output-&gt;WriteLittleEndian32(magic_number);
coded_output-&gt;WriteVarint32(strlen(text));
coded_output-&gt;WriteRaw(text, strlen(text));

delete coded_output;
delete raw_output;
close(fd);</pre>

<p><a href='#CodedInputStream'>CodedInputStream</a> example: </p>

<pre>// Read a file created by the above code.
int fd = open("myfile", O_RDONLY);
ZeroCopyInputStream* raw_input = new FileInputStream(fd);
CodedInputStream* coded_input = new CodedInputStream(raw_input);

coded_input-&gt;ReadLittleEndian32(&amp;magic_number);
if (magic_number != 1234) {
  cerr &lt;&lt; "File not in expected format." &lt;&lt; endl;
  return;
}

uint32 size;
coded_input-&gt;ReadVarint32(&amp;size);

char* text = new char[[]size + 1];
coded_input-&gt;ReadRaw(buffer, size);
text[[]size] = '\0';

delete coded_input;
delete raw_input;
close(fd);

cout &lt;&lt; "Text is: " &lt;&lt; text &lt;&lt; endl;
delete [[]] text;</pre>

<p>For those who are interested, varint encoding is defined as follows:</p>

<p>The encoding operates on unsigned integers of up to 64 bits in length. Each byte of the encoded value has the format:</p>

<ul>
  <li>bits 0-6: Seven bits of the number being encoded.</li>
  <li>bit 7: Zero if this is the last byte in the encoding (in which case all remaining bits of the number are zero) or 1 if more bytes follow. The first byte contains the least-significant 7 bits of the number, the second byte (if present) contains the next-least-significant 7 bits, and so on. So, the binary number 1011000101011 would be encoded in two bytes as "10101011 00101100".</li>
</ul>

<p>In theory, varint could be used to encode integers of any length. However, for practicality we set a limit at 64 bits. The maximum encoded length of a number is thus 10 bytes. </p>

<table width="100%"><tr><th colspan="2"><h3 style="margin-top: 4px">Classes in this file</h3></th></tr><tr><td><div><code><a href="#CodedInputStream">CodedInputStream</a></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Class which reads and decodes binary data which is composed of varint- encoded integers and fixed-width pieces. </div></td></tr><tr><td><div><code><a href="#EpsCopyOutputStream">EpsCopyOutputStream</a></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;"><a href='#EpsCopyOutputStream'>EpsCopyOutputStream</a> wraps a <a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a> and exposes a new stream, which has the property you can write kSlopBytes (16 bytes) from the current position without bounds checks. </div></td></tr><tr><td><div><code><a href="#CodedOutputStream">CodedOutputStream</a></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Class which encodes and writes binary data which is composed of varint- encoded integers and fixed-width pieces. </div></td></tr><tr><td><div><code><a href="#CodedOutputStream.StaticVarintSize32">CodedOutputStream::StaticVarintSize32</a></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Compile-time equivalent of <a href='#CodedOutputStream.VarintSize32'>VarintSize32()</a>. </div></td></tr></table><h2 id="CodedInputStream">class CodedInputStream</h2><p><code>#include &lt;<a href="#">google/protobuf/io/coded_stream.h</a>&gt;<br>namespace <a href="#google.protobuf.io">google::protobuf::io</a></code></p><p>Class which reads and decodes binary data which is composed of varint- encoded integers and fixed-width pieces. </p><p>Wraps a <a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>ZeroCopyInputStream</a>. Most users will not need to deal with <a href='#CodedInputStream'>CodedInputStream</a>.</p>
<p>Most methods of <a href='#CodedInputStream'>CodedInputStream</a> that return a bool return false if an underlying I/O error occurs or if the data is malformed. Once such a failure occurs, the <a href='#CodedInputStream'>CodedInputStream</a> is broken and is no longer useful. After a failure, callers also should assume writes to "out" args may have occurred, though nothing useful can be determined from those writes. </p>
<table><tr><th colspan="2"><h3 style="margin-top: 4px">Members</h3></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>explicit </code></td><td style="border-left-width: 0px"id="CodedInputStream.CodedInputStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>CodedInputStream</b>(<a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>ZeroCopyInputStream</a> * input)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Create a <a href='#CodedInputStream'>CodedInputStream</a> that reads from the given <a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>ZeroCopyInputStream</a>. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>explicit </code></td><td style="border-left-width: 0px"id="CodedInputStream.CodedInputStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>CodedInputStream</b>(const uint8 * buffer, int size)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Create a <a href='#CodedInputStream'>CodedInputStream</a> that reads from the given flat array.  <a href="#CodedInputStream.CodedInputStream.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="CodedInputStream.~CodedInputStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>~CodedInputStream</b>()</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Destroy the <a href='#CodedInputStream'>CodedInputStream</a> and position the underlying <a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>ZeroCopyInputStream</a> at the first unread byte.  <a href="#CodedInputStream.~CodedInputStream.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="CodedInputStream.IsFlat"><div style="padding-left: 16px; text-indent: -16px"><code><b>IsFlat</b>() const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Return true if this <a href='#CodedInputStream'>CodedInputStream</a> reads from a flat array instead of a <a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>ZeroCopyInputStream</a>. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="CodedInputStream.Skip"><div style="padding-left: 16px; text-indent: -16px"><code><b>Skip</b>(int count)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Skips a number of bytes.  <a href="#CodedInputStream.Skip.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="CodedInputStream.GetDirectBufferPointer"><div style="padding-left: 16px; text-indent: -16px"><code><b>GetDirectBufferPointer</b>(const void ** data, int * size)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Sets *data to point directly at the unread part of the <a href='#CodedInputStream'>CodedInputStream</a>'s underlying buffer, and *size to the size of that buffer, but does not advance the stream's current position.  <a href="#CodedInputStream.GetDirectBufferPointer.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="CodedInputStream.GetDirectBufferPointerInline"><div style="padding-left: 16px; text-indent: -16px"><code><b>GetDirectBufferPointerInline</b>(const void ** data, int * size)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Like GetDirectBufferPointer, but this method is inlined, and does not attempt to Refresh() if the buffer is currently empty. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="CodedInputStream.ReadRaw"><div style="padding-left: 16px; text-indent: -16px"><code><b>ReadRaw</b>(void * buffer, int size)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Read raw bytes, copying them into the given buffer. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="CodedInputStream.ReadString"><div style="padding-left: 16px; text-indent: -16px"><code><b>ReadString</b>(std::string * buffer, int size)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Like ReadRaw, but reads into a string. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="CodedInputStream.ReadLittleEndian32"><div style="padding-left: 16px; text-indent: -16px"><code><b>ReadLittleEndian32</b>(uint32 * value)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Read a 32-bit little-endian integer. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="CodedInputStream.ReadLittleEndian64"><div style="padding-left: 16px; text-indent: -16px"><code><b>ReadLittleEndian64</b>(uint64 * value)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Read a 64-bit little-endian integer. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="CodedInputStream.ReadVarint32"><div style="padding-left: 16px; text-indent: -16px"><code><b>ReadVarint32</b>(uint32 * value)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Read an unsigned integer with Varint encoding, truncating to 32 bits.  <a href="#CodedInputStream.ReadVarint32.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="CodedInputStream.ReadVarint64"><div style="padding-left: 16px; text-indent: -16px"><code><b>ReadVarint64</b>(uint64 * value)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Read an unsigned integer with Varint encoding. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="CodedInputStream.ReadVarintSizeAsInt"><div style="padding-left: 16px; text-indent: -16px"><code><b>ReadVarintSizeAsInt</b>(int * value)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Reads a varint off the wire into an "int".  <a href="#CodedInputStream.ReadVarintSizeAsInt.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>uint32</code></td><td style="border-left-width: 0px"id="CodedInputStream.ReadTag"><div style="padding-left: 16px; text-indent: -16px"><code><b>ReadTag</b>()</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Read a tag.  <a href="#CodedInputStream.ReadTag.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>uint32</code></td><td style="border-left-width: 0px"id="CodedInputStream.ReadTagNoLastTag"><div style="padding-left: 16px; text-indent: -16px"><code><b>ReadTagNoLastTag</b>()</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>std::pair&lt; uint32, bool &gt;</code></td><td style="border-left-width: 0px"id="CodedInputStream.ReadTagWithCutoff"><div style="padding-left: 16px; text-indent: -16px"><code><b>ReadTagWithCutoff</b>(uint32 cutoff)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">This usually a faster alternative to <a href='#CodedInputStream.ReadTag'>ReadTag()</a> when cutoff is a manifest constant.  <a href="#CodedInputStream.ReadTagWithCutoff.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>std::pair&lt; uint32, bool &gt;</code></td><td style="border-left-width: 0px"id="CodedInputStream.ReadTagWithCutoffNoLastTag"><div style="padding-left: 16px; text-indent: -16px"><code><b>ReadTagWithCutoffNoLastTag</b>(uint32 cutoff)</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="CodedInputStream.ExpectTag"><div style="padding-left: 16px; text-indent: -16px"><code><b>ExpectTag</b>(uint32 expected)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Usually returns true if calling <a href='#CodedInputStream.ReadVarint32'>ReadVarint32()</a> now would produce the given value.  <a href="#CodedInputStream.ExpectTag.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="CodedInputStream.ExpectAtEnd"><div style="padding-left: 16px; text-indent: -16px"><code><b>ExpectAtEnd</b>()</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Usually returns true if no more bytes can be read.  <a href="#CodedInputStream.ExpectAtEnd.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="CodedInputStream.LastTagWas"><div style="padding-left: 16px; text-indent: -16px"><code><b>LastTagWas</b>(uint32 expected)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">If the last call to <a href='#CodedInputStream.ReadTag'>ReadTag()</a> or <a href='#CodedInputStream.ReadTagWithCutoff'>ReadTagWithCutoff()</a> returned the given value, returns true.  <a href="#CodedInputStream.LastTagWas.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="CodedInputStream.SetLastTag"><div style="padding-left: 16px; text-indent: -16px"><code><b>SetLastTag</b>(uint32 tag)</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="CodedInputStream.ConsumedEntireMessage"><div style="padding-left: 16px; text-indent: -16px"><code><b>ConsumedEntireMessage</b>()</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">When parsing message (but NOT a group), this method must be called immediately after MergeFromCodedStream() returns (if it returns true) to further verify that the message ended in a legitimate way.  <a href="#CodedInputStream.ConsumedEntireMessage.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="CodedInputStream.SetConsumed"><div style="padding-left: 16px; text-indent: -16px"><code><b>SetConsumed</b>()</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>static const uint8 *</code></td><td style="border-left-width: 0px"id="CodedInputStream.ReadLittleEndian32FromArray"><div style="padding-left: 16px; text-indent: -16px"><code><b>ReadLittleEndian32FromArray</b>(const uint8 * buffer, uint32 * value)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">These methods read from an externally provided buffer.  <a href="#CodedInputStream.ReadLittleEndian32FromArray.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>static const uint8 *</code></td><td style="border-left-width: 0px"id="CodedInputStream.ReadLittleEndian64FromArray"><div style="padding-left: 16px; text-indent: -16px"><code><b>ReadLittleEndian64FromArray</b>(const uint8 * buffer, uint64 * value)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Read a 64-bit little-endian integer.  <a href="#CodedInputStream.ReadLittleEndian64FromArray.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>static const uint8 *</code></td><td style="border-left-width: 0px"id="CodedInputStream.ExpectTagFromArray"><div style="padding-left: 16px; text-indent: -16px"><code><b>ExpectTagFromArray</b>(const uint8 * buffer, uint32 expected)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Like above, except this reads from the specified buffer.  <a href="#CodedInputStream.ExpectTagFromArray.details">more...</a></div></td></tr><tr><th colspan="2"><h3 style="margin-top: 4px; margin-bottom: 4px;">Limits</h3><div style="font-style: italic; font-weight: normal;">Limits are used when parsing length-delimited embedded messages. After the message's length is read, <a href='#CodedInputStream.PushLimit'>PushLimit()</a> is used to prevent the <a href='#CodedInputStream'>CodedInputStream</a> from reading beyond that length. Once the embedded message has been parsed, <a href='#CodedInputStream.PopLimit'>PopLimit()</a> is called to undo the limit. </div></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>typedef</code></td><td style="border-left-width: 0px"id="CodedInputStream.Limit"><div style="padding-left: 16px; text-indent: -16px"><code>int <b>Limit</b></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Opaque type used with <a href='#CodedInputStream.PushLimit'>PushLimit()</a> and <a href='#CodedInputStream.PopLimit'>PopLimit()</a>.  <a href="#CodedInputStream.Limit.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code><a href='#CodedInputStream.Limit'>Limit</a></code></td><td style="border-left-width: 0px"id="CodedInputStream.PushLimit"><div style="padding-left: 16px; text-indent: -16px"><code><b>PushLimit</b>(int byte_limit)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Places a limit on the number of bytes that the stream may read, starting from the current position.  <a href="#CodedInputStream.PushLimit.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="CodedInputStream.PopLimit"><div style="padding-left: 16px; text-indent: -16px"><code><b>PopLimit</b>(<a href='#CodedInputStream.Limit'>Limit</a> limit)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Pops the last limit pushed by <a href='#CodedInputStream.PushLimit'>PushLimit()</a>.  <a href="#CodedInputStream.PopLimit.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>int</code></td><td style="border-left-width: 0px"id="CodedInputStream.BytesUntilLimit"><div style="padding-left: 16px; text-indent: -16px"><code><b>BytesUntilLimit</b>() const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Returns the number of bytes left until the nearest limit on the stack is hit, or -1 if no limits are in place. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>int</code></td><td style="border-left-width: 0px"id="CodedInputStream.CurrentPosition"><div style="padding-left: 16px; text-indent: -16px"><code><b>CurrentPosition</b>() const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Returns current position relative to the beginning of the input stream. </div></td></tr><tr><th colspan="2"><h3 style="margin-top: 4px; margin-bottom: 4px;">Total Bytes Limit</h3><div style="font-style: italic; font-weight: normal;">To prevent malicious users from sending excessively large messages and causing memory exhaustion, <a href='#CodedInputStream'>CodedInputStream</a> imposes a hard limit on the total number of bytes it will read. </div></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="CodedInputStream.int"><div style="padding-left: 16px; text-indent: -16px"><code><b>int</b> = {
    <a href='#CodedInputStream.SetTotalBytesLimit'>SetTotalBytesLimit</a>(total_bytes_limit)</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="CodedInputStream.SetTotalBytesLimit"><div style="padding-left: 16px; text-indent: -16px"><code><b>SetTotalBytesLimit</b>(int total_bytes_limit)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Sets the maximum number of bytes that this <a href='#CodedInputStream'>CodedInputStream</a> will read before refusing to continue.  <a href="#CodedInputStream.SetTotalBytesLimit.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="CodedInputStream.PROTOBUF_DEPRECATED_MSG"><div style="padding-left: 16px; text-indent: -16px"><code><b>PROTOBUF_DEPRECATED_MSG</b>("Please use the single parameter version of <a href='#CodedInputStream.SetTotalBytesLimit'>SetTotalBytesLimit</a>(). The " "second parameter is ignored." )</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>int</code></td><td style="border-left-width: 0px"id="CodedInputStream.BytesUntilTotalBytesLimit"><div style="padding-left: 16px; text-indent: -16px"><code><b>BytesUntilTotalBytesLimit</b>() const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">The Total Bytes Limit minus the Current Position, or -1 if the total bytes limit is INT_MAX. </div></td></tr><tr><th colspan="2"><h3 style="margin-top: 4px; margin-bottom: 4px;">Recursion Limit</h3><div style="font-style: italic; font-weight: normal;">
<p>To prevent corrupt or malicious messages from causing stack overflows, we must keep track of the depth of recursion when parsing embedded messages and groups.</p>
<p><a href='#CodedInputStream'>CodedInputStream</a> keeps track of this because it is the only object that is passed down the stack during parsing. </p>
</div></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="CodedInputStream.SetRecursionLimit"><div style="padding-left: 16px; text-indent: -16px"><code><b>SetRecursionLimit</b>(int limit)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Sets the maximum recursion depth. The default is 100. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>int</code></td><td style="border-left-width: 0px"id="CodedInputStream.RecursionBudget"><div style="padding-left: 16px; text-indent: -16px"><code><b>RecursionBudget</b>()</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="CodedInputStream.IncrementRecursionDepth"><div style="padding-left: 16px; text-indent: -16px"><code><b>IncrementRecursionDepth</b>()</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Increments the current recursion depth.  <a href="#CodedInputStream.IncrementRecursionDepth.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="CodedInputStream.DecrementRecursionDepth"><div style="padding-left: 16px; text-indent: -16px"><code><b>DecrementRecursionDepth</b>()</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Decrements the recursion depth if possible. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="CodedInputStream.UnsafeDecrementRecursionDepth"><div style="padding-left: 16px; text-indent: -16px"><code><b>UnsafeDecrementRecursionDepth</b>()</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Decrements the recursion depth blindly.  <a href="#CodedInputStream.UnsafeDecrementRecursionDepth.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>std::pair&lt; <a href='#CodedInputStream.Limit'>CodedInputStream::Limit</a>, int &gt;</code></td><td style="border-left-width: 0px"id="CodedInputStream.IncrementRecursionDepthAndPushLimit"><div style="padding-left: 16px; text-indent: -16px"><code><b>IncrementRecursionDepthAndPushLimit</b>(int byte_limit)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Shorthand for make_pair(PushLimit(byte_limit), &ndash;recursion_budget_).  <a href="#CodedInputStream.IncrementRecursionDepthAndPushLimit.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code><a href='#CodedInputStream.Limit'>Limit</a></code></td><td style="border-left-width: 0px"id="CodedInputStream.ReadLengthAndPushLimit"><div style="padding-left: 16px; text-indent: -16px"><code><b>ReadLengthAndPushLimit</b>()</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Shorthand for PushLimit(ReadVarint32(&amp;length) ? length : 0). </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="CodedInputStream.DecrementRecursionDepthAndPopLimit"><div style="padding-left: 16px; text-indent: -16px"><code><b>DecrementRecursionDepthAndPopLimit</b>(<a href='#CodedInputStream.Limit'>Limit</a> limit)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Helper that is equivalent to: { bool result = <a href='#CodedInputStream.ConsumedEntireMessage'>ConsumedEntireMessage()</a>; PopLimit(limit); <a href='#CodedInputStream.UnsafeDecrementRecursionDepth'>UnsafeDecrementRecursionDepth()</a>; return result; } Using this can reduce code size and complexity in some cases.  <a href="#CodedInputStream.DecrementRecursionDepthAndPopLimit.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="CodedInputStream.CheckEntireMessageConsumedAndPopLimit"><div style="padding-left: 16px; text-indent: -16px"><code><b>CheckEntireMessageConsumedAndPopLimit</b>(<a href='#CodedInputStream.Limit'>Limit</a> limit)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Helper that is equivalent to: { bool result = <a href='#CodedInputStream.ConsumedEntireMessage'>ConsumedEntireMessage()</a>; PopLimit(limit); return result; } Using this can reduce code size and complexity in some cases. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>static int</code></td><td style="border-left-width: 0px"id="CodedInputStream.GetDefaultRecursionLimit"><div style="padding-left: 16px; text-indent: -16px"><code><b>GetDefaultRecursionLimit</b>()</code></div></td></tr><tr><th colspan="2"><h3 style="margin-top: 4px; margin-bottom: 4px;">Extension Registry</h3><div style="font-style: italic; font-weight: normal;">
<p>ADVANCED USAGE: 99.9% of people can ignore this section.</p>
<p>By default, when parsing extensions, the parser looks for extension definitions in the pool which owns the outer message's <a href='google.protobuf.descriptor#Descriptor'>Descriptor</a>. However, you may call <a href='#CodedInputStream.SetExtensionRegistry'>SetExtensionRegistry()</a> to provide an alternative pool instead. This makes it possible, for example, to parse a message using a generated class, but represent some extensions using DynamicMessage. </p>
</div></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="CodedInputStream.SetExtensionRegistry"><div style="padding-left: 16px; text-indent: -16px"><code><b>SetExtensionRegistry</b>(const <a href='google.protobuf.descriptor#DescriptorPool'>DescriptorPool</a> * pool, <a href='google.protobuf.message#MessageFactory'>MessageFactory</a> * factory)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Set the pool used to look up extensions.  <a href="#CodedInputStream.SetExtensionRegistry.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>const <a href='google.protobuf.descriptor#DescriptorPool'>DescriptorPool</a> *</code></td><td style="border-left-width: 0px"id="CodedInputStream.GetExtensionPool"><div style="padding-left: 16px; text-indent: -16px"><code><b>GetExtensionPool</b>()</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Get the <a href='google.protobuf.descriptor#DescriptorPool'>DescriptorPool</a> set via <a href='#CodedInputStream.SetExtensionRegistry'>SetExtensionRegistry()</a>, or NULL if no pool has been provided. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code><a href='google.protobuf.message#MessageFactory'>MessageFactory</a> *</code></td><td style="border-left-width: 0px"id="CodedInputStream.GetExtensionFactory"><div style="padding-left: 16px; text-indent: -16px"><code><b>GetExtensionFactory</b>()</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Get the <a href='google.protobuf.message#MessageFactory'>MessageFactory</a> set via <a href='#CodedInputStream.SetExtensionRegistry'>SetExtensionRegistry()</a>, or NULL if no factory has been provided. </div></td></tr></table> <hr><h3 id="CodedInputStream.CodedInputStream.details"><code>explicit  CodedInputStream::CodedInputStream(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const uint8 * buffer,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int size)</code></h3><div style="margin-left: 16px"><p>Create a <a href='#CodedInputStream'>CodedInputStream</a> that reads from the given flat array. </p><p>This is faster than using an <a href='google.protobuf.io.zero_copy_stream_impl_lite#ArrayInputStream'>ArrayInputStream</a>. PushLimit(size) is implied by this constructor. </p>
</div> <hr><h3 id="CodedInputStream.~CodedInputStream.details"><code>CodedInputStream::~CodedInputStream()</code></h3><div style="margin-left: 16px"><p>Destroy the <a href='#CodedInputStream'>CodedInputStream</a> and position the underlying <a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>ZeroCopyInputStream</a> at the first unread byte. </p><p>If an error occurred while reading (causing a method to return false), then the exact position of the input stream may be anywhere between the last value that was read successfully and the stream's byte limit. </p>
</div> <hr><h3 id="CodedInputStream.Skip.details"><code>bool CodedInputStream::Skip(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count)</code></h3><div style="margin-left: 16px"><p>Skips a number of bytes. </p><p>Returns false if an underlying read error occurs. </p>
</div> <hr><h3 id="CodedInputStream.GetDirectBufferPointer.details"><code>bool CodedInputStream::GetDirectBufferPointer(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const void ** data,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int * size)</code></h3><div style="margin-left: 16px"><p>Sets *data to point directly at the unread part of the <a href='#CodedInputStream'>CodedInputStream</a>'s underlying buffer, and *size to the size of that buffer, but does not advance the stream's current position. </p><p>This will always either produce a non-empty buffer or return false. If the caller consumes any of this data, it should then call <a href='#CodedInputStream.Skip'>Skip()</a> to skip over the consumed bytes. This may be useful for implementing external fast parsing routines for types of data not covered by the <a href='#CodedInputStream'>CodedInputStream</a> interface. </p>
</div> <hr><h3 id="CodedInputStream.ReadVarint32.details"><code>bool CodedInputStream::ReadVarint32(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32 * value)</code></h3><div style="margin-left: 16px"><p>Read an unsigned integer with Varint encoding, truncating to 32 bits. </p><p>Reading a 32-bit value is equivalent to reading a 64-bit one and casting it to uint32, but may be more efficient. </p>
</div> <hr><h3 id="CodedInputStream.ReadVarintSizeAsInt.details"><code>bool CodedInputStream::ReadVarintSizeAsInt(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int * value)</code></h3><div style="margin-left: 16px"><p>Reads a varint off the wire into an "int". </p><p>This should be used for reading sizes off the wire (sizes of strings, submessages, bytes fields, etc).</p>
<p>The value from the wire is interpreted as unsigned. If its value exceeds the representable value of an integer on this platform, instead of truncating we return false. Truncating (as performed by <a href='#CodedInputStream.ReadVarint32'>ReadVarint32()</a> above) is an acceptable approach for fields representing an integer, but when we are parsing a size from the wire, truncating the value would result in us misparsing the payload. </p>
</div> <hr><h3 id="CodedInputStream.ReadTag.details"><code>uint32 CodedInputStream::ReadTag()</code></h3><div style="margin-left: 16px"><p>Read a tag. </p><p>This calls <a href='#CodedInputStream.ReadVarint32'>ReadVarint32()</a> and returns the result, or returns zero (which is not a valid tag) if <a href='#CodedInputStream.ReadVarint32'>ReadVarint32()</a> fails. Also, ReadTag (but not ReadTagNoLastTag) updates the last tag value, which can be checked with <a href='#CodedInputStream.LastTagWas'>LastTagWas()</a>.</p>
<p>Always inline because this is only called in one place per parse loop but it is called for every iteration of said loop, so it should be fast. GCC doesn't want to inline this by default. </p>
</div> <hr><h3 id="CodedInputStream.ReadTagWithCutoff.details"><code>std::pair&lt; uint32, bool &gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;CodedInputStream::ReadTagWithCutoff(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32 cutoff)</code></h3><div style="margin-left: 16px"><p>This usually a faster alternative to <a href='#CodedInputStream.ReadTag'>ReadTag()</a> when cutoff is a manifest constant. </p><p>It does particularly well for cutoff &gt;= 127. The first part of the return value is the tag that was read, though it can also be 0 in the cases where <a href='#CodedInputStream.ReadTag'>ReadTag()</a> would return 0. If the second part is true then the tag is known to be in [[]0, cutoff]. If not, the tag either is above cutoff or is 0. (There's intentional wiggle room when tag is 0, because that can arise in several ways, and for best performance we want to avoid an extra "is tag == 0?" check here.) </p>
</div> <hr><h3 id="CodedInputStream.ExpectTag.details"><code>bool CodedInputStream::ExpectTag(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32 expected)</code></h3><div style="margin-left: 16px"><p>Usually returns true if calling <a href='#CodedInputStream.ReadVarint32'>ReadVarint32()</a> now would produce the given value. </p><p>Will always return false if <a href='#CodedInputStream.ReadVarint32'>ReadVarint32()</a> would not return the given value. If <a href='#CodedInputStream.ExpectTag'>ExpectTag()</a> returns true, it also advances past the varint. For best performance, use a compile-time constant as the parameter. Always inline because this collapses to a small number of instructions when given a constant parameter, but GCC doesn't want to inline by default. </p>
</div> <hr><h3 id="CodedInputStream.ExpectAtEnd.details"><code>bool CodedInputStream::ExpectAtEnd()</code></h3><div style="margin-left: 16px"><p>Usually returns true if no more bytes can be read. </p><p>Always returns false if more bytes can be read. If <a href='#CodedInputStream.ExpectAtEnd'>ExpectAtEnd()</a> returns true, a subsequent call to <a href='#CodedInputStream.LastTagWas'>LastTagWas()</a> will act as if <a href='#CodedInputStream.ReadTag'>ReadTag()</a> had been called and returned zero, and <a href='#CodedInputStream.ConsumedEntireMessage'>ConsumedEntireMessage()</a> will return true. </p>
</div> <hr><h3 id="CodedInputStream.LastTagWas.details"><code>bool CodedInputStream::LastTagWas(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32 expected)</code></h3><div style="margin-left: 16px"><p>If the last call to <a href='#CodedInputStream.ReadTag'>ReadTag()</a> or <a href='#CodedInputStream.ReadTagWithCutoff'>ReadTagWithCutoff()</a> returned the given value, returns true. </p><p>Otherwise, returns false. ReadTagNoLastTag/ReadTagWithCutoffNoLastTag do not preserve the last returned value.</p>
<p>This is needed because parsers for some types of embedded messages (with field type TYPE_GROUP) don't actually know that they've reached the end of a message until they see an ENDGROUP tag, which was actually part of the enclosing message. The enclosing message would like to check that tag to make sure it had the right number, so it calls <a href='#CodedInputStream.LastTagWas'>LastTagWas()</a> on return from the embedded parser to check. </p>
</div> <hr><h3 id="CodedInputStream.ConsumedEntireMessage.details"><code>bool CodedInputStream::ConsumedEntireMessage()</code></h3><div style="margin-left: 16px"><p>When parsing message (but NOT a group), this method must be called immediately after MergeFromCodedStream() returns (if it returns true) to further verify that the message ended in a legitimate way. </p><p>For example, this verifies that parsing did not end on an end-group tag. It also checks for some cases where, due to optimizations, MergeFromCodedStream() can incorrectly return true. </p>
</div> <hr><h3 id="CodedInputStream.ReadLittleEndian32FromArray.details"><code>static const uint8 * CodedInputStream::ReadLittleEndian32FromArray(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const uint8 * buffer,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32 * value)</code></h3><div style="margin-left: 16px"><p>These methods read from an externally provided buffer. </p><p>static</p>
<p>The caller is responsible for ensuring that the buffer has sufficient space. Read a 32-bit little-endian integer. </p>
</div> <hr><h3 id="CodedInputStream.ReadLittleEndian64FromArray.details"><code>static const uint8 * CodedInputStream::ReadLittleEndian64FromArray(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const uint8 * buffer,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint64 * value)</code></h3><div style="margin-left: 16px"><p>Read a 64-bit little-endian integer. </p><p>static </p>
</div> <hr><h3 id="CodedInputStream.ExpectTagFromArray.details"><code>static const uint8 * CodedInputStream::ExpectTagFromArray(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const uint8 * buffer,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32 expected)</code></h3><div style="margin-left: 16px"><p>Like above, except this reads from the specified buffer. </p><p>The caller is responsible for ensuring that the buffer is large enough to read a varint of the expected size. For best performance, use a compile-time constant as the expected tag parameter.</p>
<p>Returns a pointer beyond the expected tag if it was found, or NULL if it was not. </p>
</div> <hr><h3 id="CodedInputStream.Limit.details"><code>typedef CodedInputStream::Limit</code></h3><div style="margin-left: 16px"><p>Opaque type used with <a href='#CodedInputStream.PushLimit'>PushLimit()</a> and <a href='#CodedInputStream.PopLimit'>PopLimit()</a>. </p><p>Do not modify values of this type yourself. The only reason that this isn't a struct with private internals is for efficiency. </p>
</div> <hr><h3 id="CodedInputStream.PushLimit.details"><code><a href='#CodedInputStream.Limit'>Limit</a> CodedInputStream::PushLimit(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int byte_limit)</code></h3><div style="margin-left: 16px"><p>Places a limit on the number of bytes that the stream may read, starting from the current position. </p><p>Once the stream hits this limit, it will act like the end of the input has been reached until <a href='#CodedInputStream.PopLimit'>PopLimit()</a> is called.</p>
<p>As the names imply, the stream conceptually has a stack of limits. The shortest limit on the stack is always enforced, even if it is not the top limit.</p>
<p>The value returned by <a href='#CodedInputStream.PushLimit'>PushLimit()</a> is opaque to the caller, and must be passed unchanged to the corresponding call to <a href='#CodedInputStream.PopLimit'>PopLimit()</a>. </p>
</div> <hr><h3 id="CodedInputStream.PopLimit.details"><code>void CodedInputStream::PopLimit(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#CodedInputStream.Limit'>Limit</a> limit)</code></h3><div style="margin-left: 16px"><p>Pops the last limit pushed by <a href='#CodedInputStream.PushLimit'>PushLimit()</a>. </p><p>The input must be the value returned by that call to <a href='#CodedInputStream.PushLimit'>PushLimit()</a>. </p>
</div> <hr><h3 id="CodedInputStream.SetTotalBytesLimit.details"><code>void CodedInputStream::SetTotalBytesLimit(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int total_bytes_limit)</code></h3><div style="margin-left: 16px"><p>Sets the maximum number of bytes that this <a href='#CodedInputStream'>CodedInputStream</a> will read before refusing to continue. </p><p>To prevent servers from allocating enormous amounts of memory to hold parsed messages, the maximum message length should be limited to the shortest length that will not harm usability. The default limit is INT_MAX (~2GB) and apps should set shorter limits if possible. An error will always be printed to stderr if the limit is reached.</p>
<p>Note: setting a limit less than the current read position is interpreted as a limit on the current position.</p>
<p>This is unrelated to <a href='#CodedInputStream.PushLimit'>PushLimit()</a>/PopLimit(). </p>
</div> <hr><h3 id="CodedInputStream.IncrementRecursionDepth.details"><code>bool CodedInputStream::IncrementRecursionDepth()</code></h3><div style="margin-left: 16px"><p>Increments the current recursion depth. </p><p>Returns true if the depth is under the limit, false if it has gone over. </p>
</div> <hr><h3 id="CodedInputStream.UnsafeDecrementRecursionDepth.details"><code>void CodedInputStream::UnsafeDecrementRecursionDepth()</code></h3><div style="margin-left: 16px"><p>Decrements the recursion depth blindly. </p><p>This is faster than <a href='#CodedInputStream.DecrementRecursionDepth'>DecrementRecursionDepth()</a>. It should be used only if all previous increments to recursion depth were successful. </p>
</div> <hr><h3 id="CodedInputStream.IncrementRecursionDepthAndPushLimit.details"><code>std::pair&lt; <a href='#CodedInputStream.Limit'>CodedInputStream::Limit</a>, int &gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;CodedInputStream::IncrementRecursionDepthAndPushLimit(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int byte_limit)</code></h3><div style="margin-left: 16px"><p>Shorthand for make_pair(PushLimit(byte_limit), &ndash;recursion_budget_). </p><p>Using this can reduce code size and complexity in some cases. The caller is expected to check that the second part of the result is non-negative (to bail out if the depth of recursion is too high) and, if all is well, to later pass the first part of the result to <a href='#CodedInputStream.PopLimit'>PopLimit()</a> or similar. </p>
</div> <hr><h3 id="CodedInputStream.DecrementRecursionDepthAndPopLimit.details"><code>bool CodedInputStream::DecrementRecursionDepthAndPopLimit(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#CodedInputStream.Limit'>Limit</a> limit)</code></h3><div style="margin-left: 16px"><p>Helper that is equivalent to: { bool result = <a href='#CodedInputStream.ConsumedEntireMessage'>ConsumedEntireMessage()</a>; PopLimit(limit); <a href='#CodedInputStream.UnsafeDecrementRecursionDepth'>UnsafeDecrementRecursionDepth()</a>; return result; } Using this can reduce code size and complexity in some cases. </p><p>Do not use unless the current recursion depth is greater than zero. </p>
</div> <hr><h3 id="CodedInputStream.SetExtensionRegistry.details"><code>void CodedInputStream::SetExtensionRegistry(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const <a href='google.protobuf.descriptor#DescriptorPool'>DescriptorPool</a> * pool,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='google.protobuf.message#MessageFactory'>MessageFactory</a> * factory)</code></h3><div style="margin-left: 16px"><p>Set the pool used to look up extensions. </p><p>Most users do not need to call this as the correct pool will be chosen automatically.</p>
<p>WARNING: It is very easy to misuse this. Carefully read the requirements below. Do not use this unless you are sure you need it. Almost no one does.</p>
<p>Let's say you are parsing a message into message object m, and you want to take advantage of <a href='#CodedInputStream.SetExtensionRegistry'>SetExtensionRegistry()</a>. You must follow these requirements:</p>
<p>The given <a href='google.protobuf.descriptor#DescriptorPool'>DescriptorPool</a> must contain m-&gt;GetDescriptor(). It is not sufficient for it to simply contain a descriptor that has the same name and content &ndash; it must be the <i>exact object</i>. In other words: </p>
<pre>assert(pool-&gt;FindMessageTypeByName(m-&gt;GetDescriptor()-&gt;full_name()) ==
       m-&gt;GetDescriptor());</pre>
<p> There are two ways to satisfy this requirement: 1) Use m-&gt;GetDescriptor()-&gt;pool() as the pool. This is generally useless </p>
<pre>because this is the pool that would be used anyway if you didn't call
SetExtensionRegistry() at all.</pre>
<p> 2) Use a <a href='google.protobuf.descriptor#DescriptorPool'>DescriptorPool</a> which has m-&gt;GetDescriptor()-&gt;pool() as an </p>
<pre>"underlay".  Read the documentation for DescriptorPool for more
information about underlays.</pre>
<p>You must also provide a <a href='google.protobuf.message#MessageFactory'>MessageFactory</a>. This factory will be used to construct <a href='google.protobuf.message#Message'>Message</a> objects representing extensions. The factory's GetPrototype() MUST return non-NULL for any <a href='google.protobuf.descriptor#Descriptor'>Descriptor</a> which can be found through the provided pool.</p>
<p>If the provided factory might return instances of protocol-compiler- generated (i.e. compiled-in) types, or if the outer message object m is a generated type, then the given factory MUST have this property: If GetPrototype() is given a <a href='google.protobuf.descriptor#Descriptor'>Descriptor</a> which resides in <a href='google.protobuf.descriptor#DescriptorPool.generated_pool'>DescriptorPool::generated_pool()</a>, the factory MUST return the same prototype which <a href='google.protobuf.message#MessageFactory.generated_factory'>MessageFactory::generated_factory()</a> would return. That is, given a descriptor for a generated type, the factory must return an instance of the generated class (NOT DynamicMessage). However, when given a descriptor for a type that is NOT in generated_pool, the factory is free to return any implementation.</p>
<p>The reason for this requirement is that generated sub-objects may be accessed via the standard (non-reflection) extension accessor methods, and these methods will down-cast the object to the generated class type. If the object is not actually of that type, the results would be undefined. On the other hand, if an extension is not compiled in, then there is no way the code could end up accessing it via the standard accessors &ndash; the only way to access the extension is via reflection. When using reflection, DynamicMessage and generated messages are indistinguishable, so it's fine if these objects are represented using DynamicMessage.</p>
<p>Using <a href='google.protobuf.dynamic_message#DynamicMessageFactory'>DynamicMessageFactory</a> on which you have called SetDelegateToGeneratedFactory(true) should be sufficient to satisfy the above requirement.</p>
<p>If either pool or factory is NULL, both must be NULL.</p>
<p>Note that this feature is ignored when parsing "lite" messages as they do not have descriptors. </p>
</div><h2 id="EpsCopyOutputStream">class EpsCopyOutputStream</h2><p><code>#include &lt;<a href="#">google/protobuf/io/coded_stream.h</a>&gt;<br>namespace <a href="#google.protobuf.io">google::protobuf::io</a></code></p><p><a href='#EpsCopyOutputStream'>EpsCopyOutputStream</a> wraps a <a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a> and exposes a new stream, which has the property you can write kSlopBytes (16 bytes) from the current position without bounds checks. </p><p>The cursor into the stream is managed by the user of the class and is an explicit parameter in the methods. Careful use of this class, i.e. keep ptr a local variable, eliminates the need to for the compiler to sync the ptr value between register and memory. </p>
<table><tr><th colspan="2"><h3 style="margin-top: 4px">Members</h3></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>enum</code></td><td style="border-left-width: 0px"id="EpsCopyOutputStream.@33"><div style="padding-left: 16px; text-indent: -16px"><code><b>@33</b></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;"> <a href="#EpsCopyOutputStream.@33.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="EpsCopyOutputStream.EpsCopyOutputStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>EpsCopyOutputStream</b>(<a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a> * stream, bool deterministic, uint8 ** pp)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Initialize from a stream. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="EpsCopyOutputStream.EpsCopyOutputStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>EpsCopyOutputStream</b>(void * data, int size, bool deterministic)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Only for array serialization.  <a href="#EpsCopyOutputStream.EpsCopyOutputStream.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="EpsCopyOutputStream.EpsCopyOutputStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>EpsCopyOutputStream</b>(void * data, int size, <a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a> * stream, bool deterministic, uint8 ** pp)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Initialize from stream but with the first buffer already given (eager). </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>uint8 *</code></td><td style="border-left-width: 0px"id="EpsCopyOutputStream.Trim"><div style="padding-left: 16px; text-indent: -16px"><code><b>Trim</b>(uint8 * ptr)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Flush everything that's written into the underlying <a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a> and trims the underlying stream to the location of ptr. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>PROTOBUF_MUST_USE_RESULT uint8 *</code></td><td style="border-left-width: 0px"id="EpsCopyOutputStream.EnsureSpace"><div style="padding-left: 16px; text-indent: -16px"><code><b>EnsureSpace</b>(uint8 * ptr)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">After this it's guaranteed you can safely write kSlopBytes to ptr.  <a href="#EpsCopyOutputStream.EnsureSpace.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>uint8 *</code></td><td style="border-left-width: 0px"id="EpsCopyOutputStream.WriteRaw"><div style="padding-left: 16px; text-indent: -16px"><code><b>WriteRaw</b>(const void * data, int size, uint8 * ptr)</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>uint8 *</code></td><td style="border-left-width: 0px"id="EpsCopyOutputStream.WriteRawMaybeAliased"><div style="padding-left: 16px; text-indent: -16px"><code><b>WriteRawMaybeAliased</b>(const void * data, int size, uint8 * ptr)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Writes the buffer specified by data, size to the stream.  <a href="#EpsCopyOutputStream.WriteRawMaybeAliased.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>uint8 *</code></td><td style="border-left-width: 0px"id="EpsCopyOutputStream.WriteStringMaybeAliased"><div style="padding-left: 16px; text-indent: -16px"><code><b>WriteStringMaybeAliased</b>(uint32 num, const std::string &amp; s, uint8 * ptr)</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>uint8 *</code></td><td style="border-left-width: 0px"id="EpsCopyOutputStream.WriteBytesMaybeAliased"><div style="padding-left: 16px; text-indent: -16px"><code><b>WriteBytesMaybeAliased</b>(uint32 num, const std::string &amp; s, uint8 * ptr)</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>template uint8 *</code></td><td style="border-left-width: 0px"id="EpsCopyOutputStream.WriteString"><div style="padding-left: 16px; text-indent: -16px"><code><b>WriteString</b>(uint32 num, const T &amp; s, uint8 * ptr)</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>template uint8 *</code></td><td style="border-left-width: 0px"id="EpsCopyOutputStream.WriteBytes"><div style="padding-left: 16px; text-indent: -16px"><code><b>WriteBytes</b>(uint32 num, const T &amp; s, uint8 * ptr)</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>template uint8 *</code></td><td style="border-left-width: 0px"id="EpsCopyOutputStream.WriteInt32Packed"><div style="padding-left: 16px; text-indent: -16px"><code><b>WriteInt32Packed</b>(int num, const T &amp; r, int size, uint8 * ptr)</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>template uint8 *</code></td><td style="border-left-width: 0px"id="EpsCopyOutputStream.WriteUInt32Packed"><div style="padding-left: 16px; text-indent: -16px"><code><b>WriteUInt32Packed</b>(int num, const T &amp; r, int size, uint8 * ptr)</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>template uint8 *</code></td><td style="border-left-width: 0px"id="EpsCopyOutputStream.WriteSInt32Packed"><div style="padding-left: 16px; text-indent: -16px"><code><b>WriteSInt32Packed</b>(int num, const T &amp; r, int size, uint8 * ptr)</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>template uint8 *</code></td><td style="border-left-width: 0px"id="EpsCopyOutputStream.WriteInt64Packed"><div style="padding-left: 16px; text-indent: -16px"><code><b>WriteInt64Packed</b>(int num, const T &amp; r, int size, uint8 * ptr)</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>template uint8 *</code></td><td style="border-left-width: 0px"id="EpsCopyOutputStream.WriteUInt64Packed"><div style="padding-left: 16px; text-indent: -16px"><code><b>WriteUInt64Packed</b>(int num, const T &amp; r, int size, uint8 * ptr)</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>template uint8 *</code></td><td style="border-left-width: 0px"id="EpsCopyOutputStream.WriteSInt64Packed"><div style="padding-left: 16px; text-indent: -16px"><code><b>WriteSInt64Packed</b>(int num, const T &amp; r, int size, uint8 * ptr)</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>template uint8 *</code></td><td style="border-left-width: 0px"id="EpsCopyOutputStream.WriteEnumPacked"><div style="padding-left: 16px; text-indent: -16px"><code><b>WriteEnumPacked</b>(int num, const T &amp; r, int size, uint8 * ptr)</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>template uint8 *</code></td><td style="border-left-width: 0px"id="EpsCopyOutputStream.WriteFixedPacked"><div style="padding-left: 16px; text-indent: -16px"><code><b>WriteFixedPacked</b>(int num, const T &amp; r, uint8 * ptr)</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="EpsCopyOutputStream.HadError"><div style="padding-left: 16px; text-indent: -16px"><code><b>HadError</b>() const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Returns true if there was an underlying I/O error since this object was created. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="EpsCopyOutputStream.EnableAliasing"><div style="padding-left: 16px; text-indent: -16px"><code><b>EnableAliasing</b>(bool enabled)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Instructs the <a href='#EpsCopyOutputStream'>EpsCopyOutputStream</a> to allow the underlying <a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a> to hold pointers to the original structure instead of copying, if it supports it (i.e.  <a href="#EpsCopyOutputStream.EnableAliasing.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="EpsCopyOutputStream.SetSerializationDeterministic"><div style="padding-left: 16px; text-indent: -16px"><code><b>SetSerializationDeterministic</b>(bool value)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">See documentation on <a href='#CodedOutputStream.SetSerializationDeterministic'>CodedOutputStream::SetSerializationDeterministic</a>. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="EpsCopyOutputStream.IsSerializationDeterministic"><div style="padding-left: 16px; text-indent: -16px"><code><b>IsSerializationDeterministic</b>() const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">See documentation on <a href='#CodedOutputStream.IsSerializationDeterministic'>CodedOutputStream::IsSerializationDeterministic</a>. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>int64</code></td><td style="border-left-width: 0px"id="EpsCopyOutputStream.ByteCount"><div style="padding-left: 16px; text-indent: -16px"><code><b>ByteCount</b>(uint8 * ptr) const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">The number of bytes written to the stream at position ptr, relative to the stream's overall position. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>uint8 *</code></td><td style="border-left-width: 0px"id="EpsCopyOutputStream.SetInitialBuffer"><div style="padding-left: 16px; text-indent: -16px"><code><b>SetInitialBuffer</b>(void * data, int size)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">These methods are for <a href='#CodedOutputStream'>CodedOutputStream</a>.  <a href="#EpsCopyOutputStream.SetInitialBuffer.details">more...</a></div></td></tr></table> <hr><h3 id="EpsCopyOutputStream.@33.details"><code>enum EpsCopyOutputStream::@33 {<br>&nbsp;&nbsp;kSlopBytes = = 16<br>}</code></h3><div style="margin-left: 16px"><p></p><table><tr><td>kSlopBytes</td><td></td></tr></table></div> <hr><h3 id="EpsCopyOutputStream.EpsCopyOutputStream.details"><code> EpsCopyOutputStream::EpsCopyOutputStream(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void * data,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int size,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool deterministic)</code></h3><div style="margin-left: 16px"><p>Only for array serialization. </p><p>No overflow protection, end_ will be the pointed to the end of the array. When using this the total size is already known, so no need to maintain the slop region. </p>
</div> <hr><h3 id="EpsCopyOutputStream.EnsureSpace.details"><code>PROTOBUF_MUST_USE_RESULT uint8 * <br>&nbsp;&nbsp;&nbsp;&nbsp;EpsCopyOutputStream::EnsureSpace(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint8 * ptr)</code></h3><div style="margin-left: 16px"><p>After this it's guaranteed you can safely write kSlopBytes to ptr. </p><p>This will never fail! The underlying stream can produce an error. Use HadError to check for errors. </p>
</div> <hr><h3 id="EpsCopyOutputStream.WriteRawMaybeAliased.details"><code>uint8 * EpsCopyOutputStream::WriteRawMaybeAliased(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const void * data,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int size,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint8 * ptr)</code></h3><div style="margin-left: 16px"><p>Writes the buffer specified by data, size to the stream. </p><p>Possibly by aliasing the buffer (i.e. not copying the data). The caller is responsible to make sure the buffer is alive for the duration of the <a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a>. </p>
</div> <hr><h3 id="EpsCopyOutputStream.EnableAliasing.details"><code>void EpsCopyOutputStream::EnableAliasing(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool enabled)</code></h3><div style="margin-left: 16px"><p>Instructs the <a href='#EpsCopyOutputStream'>EpsCopyOutputStream</a> to allow the underlying <a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a> to hold pointers to the original structure instead of copying, if it supports it (i.e. </p><p>output-&gt;AllowsAliasing() is true). If the underlying stream does not support aliasing, then enabling it has no affect. For now, this only affects the behavior of <a href='#EpsCopyOutputStream.WriteRawMaybeAliased'>WriteRawMaybeAliased()</a>.</p>
<p>NOTE: It is caller's responsibility to ensure that the chunk of memory remains live until all of the data has been consumed from the stream. </p>
</div> <hr><h3 id="EpsCopyOutputStream.SetInitialBuffer.details"><code>uint8 * EpsCopyOutputStream::SetInitialBuffer(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void * data,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int size)</code></h3><div style="margin-left: 16px"><p>These methods are for <a href='#CodedOutputStream'>CodedOutputStream</a>. </p><p>Ideally they should be private but to match current behavior of <a href='#CodedOutputStream'>CodedOutputStream</a> as close as possible we allow it some functionality. </p>
</div><h2 id="CodedOutputStream">class CodedOutputStream</h2><p><code>#include &lt;<a href="#">google/protobuf/io/coded_stream.h</a>&gt;<br>namespace <a href="#google.protobuf.io">google::protobuf::io</a></code></p><p>Class which encodes and writes binary data which is composed of varint- encoded integers and fixed-width pieces. </p><p>Wraps a <a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a>. Most users will not need to deal with <a href='#CodedOutputStream'>CodedOutputStream</a>.</p>
<p>Most methods of <a href='#CodedOutputStream'>CodedOutputStream</a> which return a bool return false if an underlying I/O error occurs. Once such a failure occurs, the <a href='#CodedOutputStream'>CodedOutputStream</a> is broken and is no longer useful. The Write* methods do not return the stream status, but will invalidate the stream if an error occurs. The client can probe <a href='#CodedOutputStream.HadError'>HadError()</a> to determine the status.</p>
<p>Note that every method of <a href='#CodedOutputStream'>CodedOutputStream</a> which writes some data has a corresponding static "ToArray" version. These versions write directly to the provided buffer, returning a pointer past the last written byte. They require that the buffer has sufficient capacity for the encoded data. This allows an optimization where we check if an output stream has enough space for an entire message before we start writing and, if there is, we call only the ToArray methods to avoid doing bound checks for each individual value. i.e., in the example above:</p>
<pre>CodedOutputStream* coded_output = new CodedOutputStream(raw_output);
int magic_number = 1234;
char text[[]] = "Hello world!";

int coded_size = sizeof(magic_number) +
                 CodedOutputStream::VarintSize32(strlen(text)) +
                 strlen(text);

uint8* buffer =
    coded_output-&gt;GetDirectBufferForNBytesAndAdvance(coded_size);
if (buffer != nullptr) {
  // The output stream has enough space in the buffer: write directly to
  // the array.
  buffer = CodedOutputStream::WriteLittleEndian32ToArray(magic_number,
                                                         buffer);
  buffer = CodedOutputStream::WriteVarint32ToArray(strlen(text), buffer);
  buffer = CodedOutputStream::WriteRawToArray(text, strlen(text), buffer);
} else {
  // Make bound-checked writes, which will ask the underlying stream for
  // more space as needed.
  coded_output-&gt;WriteLittleEndian32(magic_number);
  coded_output-&gt;WriteVarint32(strlen(text));
  coded_output-&gt;WriteRaw(text, strlen(text));
}

delete coded_output;</pre>
<table><tr><th colspan="2"><h3 style="margin-top: 4px">Members</h3></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>explicit </code></td><td style="border-left-width: 0px"id="CodedOutputStream.CodedOutputStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>CodedOutputStream</b>(<a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a> * stream)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Create an <a href='#CodedOutputStream'>CodedOutputStream</a> that writes to the given <a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a>. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="CodedOutputStream.CodedOutputStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>CodedOutputStream</b>(<a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a> * stream, bool do_eager_refresh)</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="CodedOutputStream.~CodedOutputStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>~CodedOutputStream</b>()</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Destroy the <a href='#CodedOutputStream'>CodedOutputStream</a> and position the underlying <a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a> immediately after the last byte written. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="CodedOutputStream.HadError"><div style="padding-left: 16px; text-indent: -16px"><code><b>HadError</b>()</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Returns true if there was an underlying I/O error since this object was created.  <a href="#CodedOutputStream.HadError.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="CodedOutputStream.Trim"><div style="padding-left: 16px; text-indent: -16px"><code><b>Trim</b>()</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Trims any unused space in the underlying buffer so that its size matches the number of bytes written by this stream.  <a href="#CodedOutputStream.Trim.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="CodedOutputStream.Skip"><div style="padding-left: 16px; text-indent: -16px"><code><b>Skip</b>(int count)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Skips a number of bytes, leaving the bytes unmodified in the underlying buffer.  <a href="#CodedOutputStream.Skip.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="CodedOutputStream.GetDirectBufferPointer"><div style="padding-left: 16px; text-indent: -16px"><code><b>GetDirectBufferPointer</b>(void ** data, int * size)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Sets *data to point directly at the unwritten part of the <a href='#CodedOutputStream'>CodedOutputStream</a>'s underlying buffer, and *size to the size of that buffer, but does not advance the stream's current position.  <a href="#CodedOutputStream.GetDirectBufferPointer.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>uint8 *</code></td><td style="border-left-width: 0px"id="CodedOutputStream.GetDirectBufferForNBytesAndAdvance"><div style="padding-left: 16px; text-indent: -16px"><code><b>GetDirectBufferForNBytesAndAdvance</b>(int size)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">If there are at least "size" bytes available in the current buffer, returns a pointer directly into the buffer and advances over these bytes.  <a href="#CodedOutputStream.GetDirectBufferForNBytesAndAdvance.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="CodedOutputStream.WriteRaw"><div style="padding-left: 16px; text-indent: -16px"><code><b>WriteRaw</b>(const void * buffer, int size)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Write raw bytes, copying them from the given buffer. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="CodedOutputStream.WriteRawMaybeAliased"><div style="padding-left: 16px; text-indent: -16px"><code><b>WriteRawMaybeAliased</b>(const void * data, int size)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Like <a href='#CodedOutputStream.WriteRaw'>WriteRaw()</a> but will try to write aliased data if aliasing is turned on. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="CodedOutputStream.WriteString"><div style="padding-left: 16px; text-indent: -16px"><code><b>WriteString</b>(const std::string &amp; str)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Equivalent to WriteRaw(str.data(), str.size()). </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="CodedOutputStream.WriteLittleEndian32"><div style="padding-left: 16px; text-indent: -16px"><code><b>WriteLittleEndian32</b>(uint32 value)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Write a 32-bit little-endian integer. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="CodedOutputStream.WriteLittleEndian64"><div style="padding-left: 16px; text-indent: -16px"><code><b>WriteLittleEndian64</b>(uint64 value)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Write a 64-bit little-endian integer. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="CodedOutputStream.WriteVarint32"><div style="padding-left: 16px; text-indent: -16px"><code><b>WriteVarint32</b>(uint32 value)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Write an unsigned integer with Varint encoding.  <a href="#CodedOutputStream.WriteVarint32.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="CodedOutputStream.WriteVarint64"><div style="padding-left: 16px; text-indent: -16px"><code><b>WriteVarint64</b>(uint64 value)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Write an unsigned integer with Varint encoding. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="CodedOutputStream.WriteVarint32SignExtended"><div style="padding-left: 16px; text-indent: -16px"><code><b>WriteVarint32SignExtended</b>(int32 value)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Equivalent to <a href='#CodedOutputStream.WriteVarint32'>WriteVarint32()</a> except when the value is negative, in which case it must be sign-extended to a full 10 bytes. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="CodedOutputStream.WriteTag"><div style="padding-left: 16px; text-indent: -16px"><code><b>WriteTag</b>(uint32 value)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">This is identical to <a href='#CodedOutputStream.WriteVarint32'>WriteVarint32()</a>, but optimized for writing tags.  <a href="#CodedOutputStream.WriteTag.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>int</code></td><td style="border-left-width: 0px"id="CodedOutputStream.ByteCount"><div style="padding-left: 16px; text-indent: -16px"><code><b>ByteCount</b>() const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Returns the total number of bytes written since this object was created. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="CodedOutputStream.EnableAliasing"><div style="padding-left: 16px; text-indent: -16px"><code><b>EnableAliasing</b>(bool enabled)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Instructs the <a href='#CodedOutputStream'>CodedOutputStream</a> to allow the underlying <a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a> to hold pointers to the original structure instead of copying, if it supports it (i.e.  <a href="#CodedOutputStream.EnableAliasing.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="CodedOutputStream.SetSerializationDeterministic"><div style="padding-left: 16px; text-indent: -16px"><code><b>SetSerializationDeterministic</b>(bool value)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Indicate to the serializer whether the user wants deterministic serialization.  <a href="#CodedOutputStream.SetSerializationDeterministic.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="CodedOutputStream.IsSerializationDeterministic"><div style="padding-left: 16px; text-indent: -16px"><code><b>IsSerializationDeterministic</b>() const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Return whether the user wants deterministic serialization. See above. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>template void</code></td><td style="border-left-width: 0px"id="CodedOutputStream.Serialize"><div style="padding-left: 16px; text-indent: -16px"><code><b>Serialize</b>(const Func &amp; func)</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>uint8 *</code></td><td style="border-left-width: 0px"id="CodedOutputStream.Cur"><div style="padding-left: 16px; text-indent: -16px"><code><b>Cur</b>() const</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="CodedOutputStream.SetCur"><div style="padding-left: 16px; text-indent: -16px"><code><b>SetCur</b>(uint8 * ptr)</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code><a href='#EpsCopyOutputStream'>EpsCopyOutputStream</a> *</code></td><td style="border-left-width: 0px"id="CodedOutputStream.EpsCopy"><div style="padding-left: 16px; text-indent: -16px"><code><b>EpsCopy</b>()</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>static uint8 *</code></td><td style="border-left-width: 0px"id="CodedOutputStream.WriteRawToArray"><div style="padding-left: 16px; text-indent: -16px"><code><b>WriteRawToArray</b>(const void * buffer, int size, uint8 * target)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Like <a href='#CodedOutputStream.WriteRaw'>WriteRaw()</a> but writing directly to the target array.  <a href="#CodedOutputStream.WriteRawToArray.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>static uint8 *</code></td><td style="border-left-width: 0px"id="CodedOutputStream.WriteStringToArray"><div style="padding-left: 16px; text-indent: -16px"><code><b>WriteStringToArray</b>(const std::string &amp; str, uint8 * target)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Like <a href='#CodedOutputStream.WriteString'>WriteString()</a> but writing directly to the target array. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>static uint8 *</code></td><td style="border-left-width: 0px"id="CodedOutputStream.WriteStringWithSizeToArray"><div style="padding-left: 16px; text-indent: -16px"><code><b>WriteStringWithSizeToArray</b>(const std::string &amp; str, uint8 * target)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Write the varint-encoded size of str followed by str. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>static uint8 *</code></td><td style="border-left-width: 0px"id="CodedOutputStream.WriteLittleEndian32ToArray"><div style="padding-left: 16px; text-indent: -16px"><code><b>WriteLittleEndian32ToArray</b>(uint32 value, uint8 * target)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Like <a href='#CodedOutputStream.WriteLittleEndian32'>WriteLittleEndian32()</a> but writing directly to the target array. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>static uint8 *</code></td><td style="border-left-width: 0px"id="CodedOutputStream.WriteLittleEndian64ToArray"><div style="padding-left: 16px; text-indent: -16px"><code><b>WriteLittleEndian64ToArray</b>(uint64 value, uint8 * target)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Like <a href='#CodedOutputStream.WriteLittleEndian64'>WriteLittleEndian64()</a> but writing directly to the target array. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>static uint8 *</code></td><td style="border-left-width: 0px"id="CodedOutputStream.WriteVarint32ToArray"><div style="padding-left: 16px; text-indent: -16px"><code><b>WriteVarint32ToArray</b>(uint32 value, uint8 * target)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Like <a href='#CodedOutputStream.WriteVarint32'>WriteVarint32()</a> but writing directly to the target array. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>static uint8 *</code></td><td style="border-left-width: 0px"id="CodedOutputStream.WriteVarint32ToArrayOutOfLine"><div style="padding-left: 16px; text-indent: -16px"><code><b>WriteVarint32ToArrayOutOfLine</b>(uint32 value, uint8 * target)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Like <a href='#CodedOutputStream.WriteVarint32'>WriteVarint32()</a> but writing directly to the target array, and with the less common-case paths being out of line rather than inlined. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>static uint8 *</code></td><td style="border-left-width: 0px"id="CodedOutputStream.WriteVarint64ToArray"><div style="padding-left: 16px; text-indent: -16px"><code><b>WriteVarint64ToArray</b>(uint64 value, uint8 * target)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Like <a href='#CodedOutputStream.WriteVarint64'>WriteVarint64()</a> but writing directly to the target array. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>static uint8 *</code></td><td style="border-left-width: 0px"id="CodedOutputStream.WriteVarint32SignExtendedToArray"><div style="padding-left: 16px; text-indent: -16px"><code><b>WriteVarint32SignExtendedToArray</b>(int32 value, uint8 * target)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Like <a href='#CodedOutputStream.WriteVarint32SignExtended'>WriteVarint32SignExtended()</a> but writing directly to the target array. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>static uint8 *</code></td><td style="border-left-width: 0px"id="CodedOutputStream.WriteTagToArray"><div style="padding-left: 16px; text-indent: -16px"><code><b>WriteTagToArray</b>(uint32 value, uint8 * target)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Like <a href='#CodedOutputStream.WriteTag'>WriteTag()</a> but writing directly to the target array. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>static size_t</code></td><td style="border-left-width: 0px"id="CodedOutputStream.VarintSize32"><div style="padding-left: 16px; text-indent: -16px"><code><b>VarintSize32</b>(uint32 value)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Returns the number of bytes needed to encode the given value as a varint. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>static size_t</code></td><td style="border-left-width: 0px"id="CodedOutputStream.VarintSize64"><div style="padding-left: 16px; text-indent: -16px"><code><b>VarintSize64</b>(uint64 value)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Returns the number of bytes needed to encode the given value as a varint. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>static size_t</code></td><td style="border-left-width: 0px"id="CodedOutputStream.VarintSize32SignExtended"><div style="padding-left: 16px; text-indent: -16px"><code><b>VarintSize32SignExtended</b>(int32 value)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">If negative, 10 bytes. Otherwise, same as <a href='#CodedOutputStream.VarintSize32'>VarintSize32()</a>. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>static bool</code></td><td style="border-left-width: 0px"id="CodedOutputStream.IsDefaultSerializationDeterministic"><div style="padding-left: 16px; text-indent: -16px"><code><b>IsDefaultSerializationDeterministic</b>()</code></div></td></tr></table> <hr><h3 id="CodedOutputStream.HadError.details"><code>bool CodedOutputStream::HadError()</code></h3><div style="margin-left: 16px"><p>Returns true if there was an underlying I/O error since this object was created. </p><p>On should call Trim before this function in order to catch all errors. </p>
</div> <hr><h3 id="CodedOutputStream.Trim.details"><code>void CodedOutputStream::Trim()</code></h3><div style="margin-left: 16px"><p>Trims any unused space in the underlying buffer so that its size matches the number of bytes written by this stream. </p><p>The underlying buffer will automatically be trimmed when this stream is destroyed; this call is only necessary if the underlying buffer is accessed <i>before</i> the stream is destroyed. </p>
</div> <hr><h3 id="CodedOutputStream.Skip.details"><code>bool CodedOutputStream::Skip(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count)</code></h3><div style="margin-left: 16px"><p>Skips a number of bytes, leaving the bytes unmodified in the underlying buffer. </p><p>Returns false if an underlying write error occurs. This is mainly useful with <a href='#CodedOutputStream.GetDirectBufferPointer'>GetDirectBufferPointer()</a>. Note of caution, the skipped bytes may contain uninitialized data. The caller must make sure that the skipped bytes are properly initialized, otherwise you might leak bytes from your heap. </p>
</div> <hr><h3 id="CodedOutputStream.GetDirectBufferPointer.details"><code>bool CodedOutputStream::GetDirectBufferPointer(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void ** data,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int * size)</code></h3><div style="margin-left: 16px"><p>Sets *data to point directly at the unwritten part of the <a href='#CodedOutputStream'>CodedOutputStream</a>'s underlying buffer, and *size to the size of that buffer, but does not advance the stream's current position. </p><p>This will always either produce a non-empty buffer or return false. If the caller writes any data to this buffer, it should then call <a href='#CodedOutputStream.Skip'>Skip()</a> to skip over the consumed bytes. This may be useful for implementing external fast serialization routines for types of data not covered by the <a href='#CodedOutputStream'>CodedOutputStream</a> interface. </p>
</div> <hr><h3 id="CodedOutputStream.GetDirectBufferForNBytesAndAdvance.details"><code>uint8 * CodedOutputStream::GetDirectBufferForNBytesAndAdvance(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int size)</code></h3><div style="margin-left: 16px"><p>If there are at least "size" bytes available in the current buffer, returns a pointer directly into the buffer and advances over these bytes. </p><p>The caller may then write directly into this buffer (e.g. using the *ToArray static methods) rather than go through <a href='#CodedOutputStream'>CodedOutputStream</a>. If there are not enough bytes available, returns NULL. The return pointer is invalidated as soon as any other non-const method of <a href='#CodedOutputStream'>CodedOutputStream</a> is called. </p>
</div> <hr><h3 id="CodedOutputStream.WriteVarint32.details"><code>void CodedOutputStream::WriteVarint32(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32 value)</code></h3><div style="margin-left: 16px"><p>Write an unsigned integer with Varint encoding. </p><p>Writing a 32-bit value is equivalent to casting it to uint64 and writing it as a 64-bit value, but may be more efficient. </p>
</div> <hr><h3 id="CodedOutputStream.WriteTag.details"><code>void CodedOutputStream::WriteTag(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32 value)</code></h3><div style="margin-left: 16px"><p>This is identical to <a href='#CodedOutputStream.WriteVarint32'>WriteVarint32()</a>, but optimized for writing tags. </p><p>In particular, if the input is a compile-time constant, this method compiles down to a couple instructions. Always inline because otherwise the aforementioned optimization can't work, but GCC by default doesn't want to inline this. </p>
</div> <hr><h3 id="CodedOutputStream.EnableAliasing.details"><code>void CodedOutputStream::EnableAliasing(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool enabled)</code></h3><div style="margin-left: 16px"><p>Instructs the <a href='#CodedOutputStream'>CodedOutputStream</a> to allow the underlying <a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a> to hold pointers to the original structure instead of copying, if it supports it (i.e. </p><p>output-&gt;AllowsAliasing() is true). If the underlying stream does not support aliasing, then enabling it has no affect. For now, this only affects the behavior of <a href='#CodedOutputStream.WriteRawMaybeAliased'>WriteRawMaybeAliased()</a>.</p>
<p>NOTE: It is caller's responsibility to ensure that the chunk of memory remains live until all of the data has been consumed from the stream. </p>
</div> <hr><h3 id="CodedOutputStream.SetSerializationDeterministic.details"><code>void CodedOutputStream::SetSerializationDeterministic(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool value)</code></h3><div style="margin-left: 16px"><p>Indicate to the serializer whether the user wants deterministic serialization. </p><p>The default when this is not called comes from the global default, controlled by SetDefaultSerializationDeterministic.</p>
<p>What deterministic serialization means is entirely up to the driver of the serialization process (i.e. the caller of methods like WriteVarint32). In the case of serializing a proto buffer message using one of the methods of <a href='google.protobuf.message_lite#MessageLite'>MessageLite</a>, this means that for a given binary equal messages will always be serialized to the same bytes. This implies:</p>
<pre>Repeated serialization of a message will return the same bytes.

Different processes running the same binary (including on different
machines) will serialize equal messages to the same bytes.</pre>
<p>Note that this is <i>not</i> canonical across languages. It is also unstable across different builds with intervening message definition changes, due to unknown fields. Users who need canonical serialization (e.g. persistent storage in a canonical form, fingerprinting) should define their own canonicalization specification and implement the serializer using reflection APIs rather than relying on this API. </p>
</div> <hr><h3 id="CodedOutputStream.WriteRawToArray.details"><code>static uint8 * CodedOutputStream::WriteRawToArray(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const void * buffer,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int size,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint8 * target)</code></h3><div style="margin-left: 16px"><p>Like <a href='#CodedOutputStream.WriteRaw'>WriteRaw()</a> but writing directly to the target array. </p><p>This is <i>not</i> inlined, as the compiler often optimizes memcpy into inline copy loops. Since this gets called by every field with string or bytes type, inlining may lead to a significant amount of code bloat, with only a minor performance gain. </p>
</div><h2 id="CodedOutputStream.StaticVarintSize32">template struct CodedOutputStream::StaticVarintSize32</h2><p><code>#include &lt;<a href="#">google/protobuf/io/coded_stream.h</a>&gt;<br>namespace <a href="#google.protobuf.io">google::protobuf::io</a><br><br>template &lt;typename Value&gt;</code></p><p>Compile-time equivalent of <a href='#CodedOutputStream.VarintSize32'>VarintSize32()</a>. </p><table><tr><th colspan="2"><h3 style="margin-top: 4px">Members</h3></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>const size_t</code></td><td style="border-left-width: 0px"id="CodedOutputStream.StaticVarintSize32.value"><div style="padding-left: 16px; text-indent: -16px"><code><b>value</b> = = (Value &lt; (1 &lt;&lt; 7))    ? 1
                                : (Value &lt; (1 &lt;&lt; 14)) ? 2
                                : (Value &lt; (1 &lt;&lt; 21)) ? 3
                                : (Value &lt; (1 &lt;&lt; 28)) ? 4
                                                      : 5</code></div></td></tr></table>
