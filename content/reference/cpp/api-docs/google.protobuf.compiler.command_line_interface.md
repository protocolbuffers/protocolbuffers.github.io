+++
title = "command_line_interface.h"
toc_hide = "true"
linkTitle = "C++"
description = "This section contains reference documentation for working with protocol buffer classes in C++."
type = "docs"
+++

<p><code>#include &lt;google/protobuf/compiler/command_line_interface.h&gt;<br>namespace <a href="#google.protobuf.compiler">google::protobuf::compiler</a></code></p><p>Implements the Protocol Compiler front-end such that it may be reused by custom compilers written to support other languages. </p><table width="100%"><tr><th colspan="2"><h3 style="margin-top: 4px">Classes in this file</h3></th></tr><tr><td><div><code><a href="#CommandLineInterface">CommandLineInterface</a></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">This class implements the command-line interface to the protocol compiler. </div></td></tr></table><h2 id="CommandLineInterface">class CommandLineInterface</h2><p><code>#include &lt;<a href="#">google/protobuf/compiler/command_line_interface.h</a>&gt;<br>namespace <a href="#google.protobuf.compiler">google::protobuf::compiler</a></code></p><p>This class implements the command-line interface to the protocol compiler. </p><p>It is designed to make it very easy to create a custom protocol compiler supporting the languages of your choice. For example, if you wanted to create a custom protocol compiler binary which includes both the regular C++ support plus support for your own custom output "Foo", you would write a class "FooGenerator" which implements the <a href='google.protobuf.compiler.code_generator#CodeGenerator'>CodeGenerator</a> interface, then write a main() procedure like this:</p>

<pre>int main(int argc, char* argv[[]]) {
  google::protobuf::compiler::CommandLineInterface cli;

  // Support generation of C++ source and headers.
  google::protobuf::compiler::cpp::CppGenerator cpp_generator;
  cli.RegisterGenerator("--cpp_out", &amp;cpp_generator,
    "Generate C++ source and header.");

  // Support generation of Foo code.
  FooGenerator foo_generator;
  cli.RegisterGenerator("--foo_out", &amp;foo_generator,
    "Generate Foo file.");

  return cli.Run(argc, argv);
}</pre>

<p>The compiler is invoked with syntax like: </p>

<pre>protoc --cpp_out=outdir --foo_out=outdir --proto_path=src src/foo.proto</pre>

<p>The .proto file to compile can be specified on the command line using either its physical file path, or a virtual path relative to a directory specified in &ndash;proto_path. For example, for src/foo.proto, the following two protoc invocations work the same way: </p>

<pre>1. protoc --proto_path=src src/foo.proto (physical file path)
2. protoc --proto_path=src foo.proto (virtual path relative to src)</pre>

<p>If a file path can be interpreted both as a physical file path and as a relative virtual path, the physical file path takes precedence.</p>

<p>For a full description of the command-line syntax, invoke it with &ndash;help. </p>

<table><tr><th colspan="2"><h3 style="margin-top: 4px">Members</h3></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>const char *const</code></td><td style="border-left-width: 0px"id="CommandLineInterface.kPathSeparator"><div style="padding-left: 16px; text-indent: -16px"><code><b>kPathSeparator</b></code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="CommandLineInterface.CommandLineInterface"><div style="padding-left: 16px; text-indent: -16px"><code><b>CommandLineInterface</b>()</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="CommandLineInterface.~CommandLineInterface"><div style="padding-left: 16px; text-indent: -16px"><code><b>~CommandLineInterface</b>()</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="CommandLineInterface.RegisterGenerator"><div style="padding-left: 16px; text-indent: -16px"><code><b>RegisterGenerator</b>(const std::string &amp; flag_name, <a href='google.protobuf.compiler.code_generator#CodeGenerator'>CodeGenerator</a> * generator, const std::string &amp; help_text)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Register a code generator for a language.  <a href="#CommandLineInterface.RegisterGenerator.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="CommandLineInterface.RegisterGenerator"><div style="padding-left: 16px; text-indent: -16px"><code><b>RegisterGenerator</b>(const std::string &amp; flag_name, const std::string &amp; option_flag_name, <a href='google.protobuf.compiler.code_generator#CodeGenerator'>CodeGenerator</a> * generator, const std::string &amp; help_text)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Register a code generator for a language.  <a href="#CommandLineInterface.RegisterGenerator.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="CommandLineInterface.AllowPlugins"><div style="padding-left: 16px; text-indent: -16px"><code><b>AllowPlugins</b>(const std::string &amp; exe_name_prefix)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Enables "plugins".  <a href="#CommandLineInterface.AllowPlugins.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>int</code></td><td style="border-left-width: 0px"id="CommandLineInterface.Run"><div style="padding-left: 16px; text-indent: -16px"><code><b>Run</b>(int argc, const char *const argv)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Run the Protocol Compiler with the given command-line parameters.  <a href="#CommandLineInterface.Run.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="CommandLineInterface.SetInputsAreProtoPathRelative"><div style="padding-left: 16px; text-indent: -16px"><code><b>SetInputsAreProtoPathRelative</b>(bool )</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">DEPRECATED.  <a href="#CommandLineInterface.SetInputsAreProtoPathRelative.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="CommandLineInterface.SetVersionInfo"><div style="padding-left: 16px; text-indent: -16px"><code><b>SetVersionInfo</b>(const std::string &amp; text)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Provides some text which will be printed when the &ndash;version flag is used.  <a href="#CommandLineInterface.SetVersionInfo.details">more...</a></div></td></tr></table> <hr><h3 id="CommandLineInterface.RegisterGenerator.details"><code>void CommandLineInterface::RegisterGenerator(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string &amp; flag_name,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='google.protobuf.compiler.code_generator#CodeGenerator'>CodeGenerator</a> * generator,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string &amp; help_text)</code></h3><div style="margin-left: 16px"><p>Register a code generator for a language. </p><p>Parameters:</p>
<ul>
  <li>flag_name: The command-line flag used to specify an output file of this type. The name must start with a '-'. If the name is longer than one letter, it must start with two '-'s.</li>
  <li>generator: The <a href='google.protobuf.compiler.code_generator#CodeGenerator'>CodeGenerator</a> which will be called to generate files of this type.</li>
  <li>help_text: Text describing this flag in the &ndash;help output.</li>
</ul>
<p>Some generators accept extra parameters. You can specify this parameter on the command-line by placing it before the output directory, separated by a colon: </p>
<pre>protoc --foo_out=enable_bar:outdir</pre>
<p> The text before the colon is passed to <a href='google.protobuf.compiler.code_generator#CodeGenerator.Generate'>CodeGenerator::Generate()</a> as the "parameter". </p>
</div> <hr><h3 id="CommandLineInterface.RegisterGenerator.details"><code>void CommandLineInterface::RegisterGenerator(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string &amp; flag_name,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string &amp; option_flag_name,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='google.protobuf.compiler.code_generator#CodeGenerator'>CodeGenerator</a> * generator,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string &amp; help_text)</code></h3><div style="margin-left: 16px"><p>Register a code generator for a language. </p><p>Besides flag_name you can specify another option_flag_name that could be used to pass extra parameters to the registered code generator. Suppose you have registered a generator by calling: </p>
<pre>command_line_interface.RegisterGenerator("--foo_out", "--foo_opt", ...)</pre>
<p> Then you could invoke the compiler with a command like: </p>
<pre>protoc --foo_out=enable_bar:outdir --foo_opt=enable_baz</pre>
<p> This will pass "enable_bar,enable_baz" as the parameter to the generator. </p>
</div> <hr><h3 id="CommandLineInterface.AllowPlugins.details"><code>void CommandLineInterface::AllowPlugins(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string &amp; exe_name_prefix)</code></h3><div style="margin-left: 16px"><p>Enables "plugins". </p><p>In this mode, if a command-line flag ends with "_out" but does not match any registered generator, the compiler will attempt to find a "plugin" to implement the generator. Plugins are just executables. They should live somewhere in the PATH.</p>
<p>The compiler determines the executable name to search for by concatenating exe_name_prefix with the unrecognized flag name, removing "_out". So, for example, if exe_name_prefix is "protoc-" and you pass the flag &ndash;foo_out, the compiler will try to run the program "protoc-gen-foo".</p>
<p>The plugin program should implement the following usage: </p>
<pre>plugin [[]--out=OUTDIR] [[]--parameter=PARAMETER] PROTO_FILES &lt; DESCRIPTORS</pre>
<p>&ndash;out indicates the output directory (as passed to the &ndash;foo_out parameter); if omitted, the current directory should be used. &ndash;parameter gives the generator parameter, if any was provided (see below). The PROTO_FILES list the .proto files which were given on the compiler command-line; these are the files for which the plugin is expected to generate output code. Finally, DESCRIPTORS is an encoded FileDescriptorSet (as defined in descriptor.proto). This is piped to the plugin's stdin. The set will include descriptors for all the files listed in PROTO_FILES as well as all files that they import. The plugin MUST NOT attempt to read the PROTO_FILES directly &ndash; it must use the FileDescriptorSet.</p>
<p>The plugin should generate whatever files are necessary, as code generators normally do. It should write the names of all files it generates to stdout. The names should be relative to the output directory, NOT absolute names or relative to the current directory. If any errors occur, error messages should be written to stderr. If an error is fatal, the plugin should exit with a non-zero exit code.</p>
<p>Plugins can have generator parameters similar to normal built-in generators. Extra generator parameters can be passed in via a matching "_opt" parameter. For example: </p>
<pre>protoc --plug_out=enable_bar:outdir --plug_opt=enable_baz</pre>
<p> This will pass "enable_bar,enable_baz" as the parameter to the plugin. </p>
</div> <hr><h3 id="CommandLineInterface.Run.details"><code>int CommandLineInterface::Run(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int argc,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char *const argv)</code></h3><div style="margin-left: 16px"><p>Run the Protocol Compiler with the given command-line parameters. </p><p>Returns the error code which should be returned by main().</p>
<p>It may not be safe to call <a href='#CommandLineInterface.Run'>Run()</a> in a multithreaded environment because it calls strerror(). I'm not sure why you'd want to do this anyway. </p>
</div> <hr><h3 id="CommandLineInterface.SetInputsAreProtoPathRelative.details"><code>void CommandLineInterface::SetInputsAreProtoPathRelative(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool )</code></h3><div style="margin-left: 16px"><p>DEPRECATED. </p><p>Calling this method has no effect. Protocol compiler now always try to find the .proto file relative to the current directory first and if the file is not found, it will then treat the input path as a virtual path. </p>
</div> <hr><h3 id="CommandLineInterface.SetVersionInfo.details"><code>void CommandLineInterface::SetVersionInfo(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string &amp; text)</code></h3><div style="margin-left: 16px"><p>Provides some text which will be printed when the &ndash;version flag is used. </p><p>The version of libprotoc will also be printed on the next line after this text. </p>
</div>
