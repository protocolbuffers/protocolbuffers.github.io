

+++
title = "message_lite.h"
toc_hide = "true"
linkTitle = "C++"
description = "This section contains reference documentation for working with protocol buffer classes in C++."
type = "docs"
+++

<p><code>#include &lt;google/protobuf/message_lite.h&gt;<br>namespace <a href="#google.protobuf">google::protobuf</a></code></p><p>Defines <a href='#MessageLite'>MessageLite</a>, the abstract interface implemented by all (lite and non-lite) protocol message objects. </p><table width="100%"><tr><th colspan="2"><h3 style="margin-top: 4px">Classes in this file</h3></th></tr><tr><td><div><code><a href="#MessageLite">MessageLite</a></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Interface to light weight protocol messages. </div></td></tr></table><table><tr><th colspan="2"><h3 style="margin-top: 4px">File Members</h3><div style="font-style: italic; font-weight: normal;">These definitions are not part of any class.</div></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="ShutdownProtobufLibrary"><div style="padding-left: 16px; text-indent: -16px"><code><b>ShutdownProtobufLibrary</b>()</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Shut down the entire protocol buffers library, deleting all static-duration objects allocated by the library or by generated .pb.cc files.  <a href="#ShutdownProtobufLibrary.details">more...</a></div></td></tr></table> <hr><h3 id="ShutdownProtobufLibrary.details"><code>void protobuf::ShutdownProtobufLibrary()</code></h3><div style="margin-left: 16px"><p>Shut down the entire protocol buffers library, deleting all static-duration objects allocated by the library or by generated .pb.cc files. </p><p>There are two reasons you might want to call this:</p>

<ul>
  <li>You use a draconian definition of "memory leak" in which you expect every single malloc() to have a corresponding free(), even for objects which live until program exit.</li>
  <li>You are writing a dynamically-loaded library which needs to clean up after itself when the library is unloaded.</li>
</ul>

<p>It is safe to call this multiple times. However, it is not safe to use any other part of the protocol buffers library after <a href='#ShutdownProtobufLibrary'>ShutdownProtobufLibrary()</a> has been called. Furthermore this call is not thread safe, user needs to synchronize multiple calls. </p>
</div><h2 id="MessageLite">class MessageLite</h2><p><code>#include &lt;<a href="#">google/protobuf/message_lite.h</a>&gt;<br>namespace <a href="#google.protobuf">google::protobuf</a></code></p><p>Interface to light weight protocol messages. </p><p>This interface is implemented by all protocol message objects. Non-lite messages additionally implement the <a href='google.protobuf.message#Message'>Message</a> interface, which is a subclass of <a href='#MessageLite'>MessageLite</a>. Use <a href='#MessageLite'>MessageLite</a> instead when you only need the subset of features which it supports &ndash; namely, nothing that uses descriptors or reflection. You can instruct the protocol compiler to generate classes which implement only <a href='#MessageLite'>MessageLite</a>, not the full <a href='google.protobuf.message#Message'>Message</a> interface, by adding the following line to the .proto file:</p>

<pre>option optimize_for = LITE_RUNTIME;</pre>

<p>This is particularly useful on resource-constrained systems where the full protocol buffers runtime library is too big.</p>

<p>Note that on non-constrained systems (e.g. servers) when you need to link in lots of protocol definitions, a better way to reduce total code footprint is to use optimize_for = CODE_SIZE. This will make the generated code smaller while still supporting all the same features (at the expense of speed). optimize_for = LITE_RUNTIME is best when you only have a small number of message types linked into your binary, in which case the size of the protocol buffers runtime itself is the biggest problem.</p>

<p>Users must not derive from this class. Only the protocol compiler and the internal library are allowed to create subclasses. </p>

<p>Known subclasses:</p><ul><li><code><a href="google.protobuf.message#Message">Message</a></code></li></ul><table><tr><th colspan="2"><h3 style="margin-top: 4px">Members</h3></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>enum</code></td><td style="border-left-width: 0px"id="MessageLite.ParseFlags"><div style="padding-left: 16px; text-indent: -16px"><code><b>ParseFlags</b></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;"> <a href="#MessageLite.ParseFlags.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>protected internal::InternalMetadata</code></td><td style="border-left-width: 0px"id="MessageLite._internal_metadata_"><div style="padding-left: 16px; text-indent: -16px"><code><b>_internal_metadata_</b></code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>constexpr</code></td><td style="border-left-width: 0px"id="MessageLite.MessageLite"><div style="padding-left: 16px; text-indent: -16px"><code><b>MessageLite</b>()</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual </code></td><td style="border-left-width: 0px"id="MessageLite.~MessageLite"><div style="padding-left: 16px; text-indent: -16px"><code><b>~MessageLite</b>()</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>template bool</code></td><td style="border-left-width: 0px"id="MessageLite.ParseFrom"><div style="padding-left: 16px; text-indent: -16px"><code><b>ParseFrom</b>(const T &amp; input)</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual uint8 *</code></td><td style="border-left-width: 0px"id="MessageLite._InternalSerialize"><div style="padding-left: 16px; text-indent: -16px"><code><b>_InternalSerialize</b>(uint8 * ptr, <a href='google.protobuf.io.coded_stream#EpsCopyOutputStream'>io::EpsCopyOutputStream</a> * stream) const  = 0</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Fast path when conditions match (ie.  <a href="#MessageLite._InternalSerialize.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="MessageLite.IsInitializedWithErrors"><div style="padding-left: 16px; text-indent: -16px"><code><b>IsInitializedWithErrors</b>() const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Identical to <a href='#MessageLite.IsInitialized'>IsInitialized()</a> except that it logs an error message. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>protected template static T *</code></td><td style="border-left-width: 0px"id="MessageLite.CreateMaybeMessage"><div style="padding-left: 16px; text-indent: -16px"><code><b>CreateMaybeMessage</b>(<a href='google.protobuf.arena#Arena'>Arena</a> * arena)</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>protected explicit </code></td><td style="border-left-width: 0px"id="MessageLite.MessageLite"><div style="padding-left: 16px; text-indent: -16px"><code><b>MessageLite</b>(<a href='google.protobuf.arena#Arena'>Arena</a> * arena)</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>protected <a href='google.protobuf.arena#Arena'>Arena</a> *</code></td><td style="border-left-width: 0px"id="MessageLite.GetOwningArena"><div style="padding-left: 16px; text-indent: -16px"><code><b>GetOwningArena</b>() const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Returns the arena, if any, that directly owns this message and its internal memory (<a href='google.protobuf.arena#Arena.Own'>Arena::Own</a> is different in that the arena doesn't directly own the internal memory).  <a href="#MessageLite.GetOwningArena.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>protected <a href='google.protobuf.arena#Arena'>Arena</a> *</code></td><td style="border-left-width: 0px"id="MessageLite.GetArenaForAllocation"><div style="padding-left: 16px; text-indent: -16px"><code><b>GetArenaForAllocation</b>() const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Returns the arena, used for allocating internal objects(e.g., child messages, etc), or owning incoming objects (e.g., set allocated). </div></td></tr><tr><th colspan="2"><h3 style="margin-top: 4px; margin-bottom: 4px;">Basic Operations</h3><div style="font-style: italic; font-weight: normal;"></div></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual std::string</code></td><td style="border-left-width: 0px"id="MessageLite.GetTypeName"><div style="padding-left: 16px; text-indent: -16px"><code><b>GetTypeName</b>() const  = 0</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Get the name of this message type, e.g. "foo.bar.BazProto". </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual <a href='#MessageLite'>MessageLite</a> *</code></td><td style="border-left-width: 0px"id="MessageLite.New"><div style="padding-left: 16px; text-indent: -16px"><code><b>New</b>() const  = 0</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Construct a new instance of the same type.  <a href="#MessageLite.New.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual <a href='#MessageLite'>MessageLite</a> *</code></td><td style="border-left-width: 0px"id="MessageLite.New"><div style="padding-left: 16px; text-indent: -16px"><code><b>New</b>(<a href='google.protobuf.arena#Arena'>Arena</a> * arena) const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Construct a new instance on the arena.  <a href="#MessageLite.New.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code><a href='google.protobuf.arena#Arena'>Arena</a> *</code></td><td style="border-left-width: 0px"id="MessageLite.GetArena"><div style="padding-left: 16px; text-indent: -16px"><code><b>GetArena</b>() const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Same as GetOwningArena. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void *</code></td><td style="border-left-width: 0px"id="MessageLite.GetMaybeArenaPointer"><div style="padding-left: 16px; text-indent: -16px"><code><b>GetMaybeArenaPointer</b>() const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Get a pointer that may be equal to this message's arena, or may not be.  <a href="#MessageLite.GetMaybeArenaPointer.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual void</code></td><td style="border-left-width: 0px"id="MessageLite.Clear"><div style="padding-left: 16px; text-indent: -16px"><code><b>Clear</b>()  = 0</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Clear all fields of the message and set them to their default values.  <a href="#MessageLite.Clear.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual bool</code></td><td style="border-left-width: 0px"id="MessageLite.IsInitialized"><div style="padding-left: 16px; text-indent: -16px"><code><b>IsInitialized</b>() const  = 0</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Quickly check if all required fields have values set. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual std::string</code></td><td style="border-left-width: 0px"id="MessageLite.InitializationErrorString"><div style="padding-left: 16px; text-indent: -16px"><code><b>InitializationErrorString</b>() const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">This is not implemented for Lite messages &ndash; it just returns "(cannot
determine missing fields for lite message)".  <a href="#MessageLite.InitializationErrorString.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual void</code></td><td style="border-left-width: 0px"id="MessageLite.CheckTypeAndMergeFrom"><div style="padding-left: 16px; text-indent: -16px"><code><b>CheckTypeAndMergeFrom</b>(const <a href='#MessageLite'>MessageLite</a> &amp; other)  = 0</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">If |other| is the exact same class as this, calls MergeFrom().  <a href="#MessageLite.CheckTypeAndMergeFrom.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>std::string</code></td><td style="border-left-width: 0px"id="MessageLite.DebugString"><div style="padding-left: 16px; text-indent: -16px"><code><b>DebugString</b>() const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">These methods return a human-readable summary of the message.  <a href="#MessageLite.DebugString.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>std::string</code></td><td style="border-left-width: 0px"id="MessageLite.ShortDebugString"><div style="padding-left: 16px; text-indent: -16px"><code><b>ShortDebugString</b>() const</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>std::string</code></td><td style="border-left-width: 0px"id="MessageLite.Utf8DebugString"><div style="padding-left: 16px; text-indent: -16px"><code><b>Utf8DebugString</b>() const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;"><a href='#MessageLite.DebugString'>MessageLite::DebugString</a> is already Utf8 Safe.  <a href="#MessageLite.Utf8DebugString.details">more...</a></div></td></tr><tr><th colspan="2"><h3 style="margin-top: 4px; margin-bottom: 4px;">Parsing</h3><div style="font-style: italic; font-weight: normal;">
<p>Methods for parsing in protocol buffer format.</p>

<p>Most of these are just simple wrappers around <a href='#MessageLite.MergeFromCodedStream'>MergeFromCodedStream()</a>. <a href='#MessageLite.Clear'>Clear()</a> will be called before merging the input. </p>
</div></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>PROTOBUF_ATTRIBUTE_REINITIALIZES bool</code></td><td style="border-left-width: 0px"id="MessageLite.ParseFromCodedStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>ParseFromCodedStream</b>(<a href='google.protobuf.io.coded_stream#CodedInputStream'>io::CodedInputStream</a> * input)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Fill the message with a protocol buffer parsed from the given input stream.  <a href="#MessageLite.ParseFromCodedStream.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>PROTOBUF_ATTRIBUTE_REINITIALIZES bool</code></td><td style="border-left-width: 0px"id="MessageLite.ParsePartialFromCodedStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>ParsePartialFromCodedStream</b>(<a href='google.protobuf.io.coded_stream#CodedInputStream'>io::CodedInputStream</a> * input)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Like <a href='#MessageLite.ParseFromCodedStream'>ParseFromCodedStream()</a>, but accepts messages that are missing required fields. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>PROTOBUF_ATTRIBUTE_REINITIALIZES bool</code></td><td style="border-left-width: 0px"id="MessageLite.ParseFromZeroCopyStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>ParseFromZeroCopyStream</b>(<a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>io::ZeroCopyInputStream</a> * input)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Read a protocol buffer from the given zero-copy input stream.  <a href="#MessageLite.ParseFromZeroCopyStream.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>PROTOBUF_ATTRIBUTE_REINITIALIZES bool</code></td><td style="border-left-width: 0px"id="MessageLite.ParsePartialFromZeroCopyStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>ParsePartialFromZeroCopyStream</b>(<a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>io::ZeroCopyInputStream</a> * input)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Like <a href='#MessageLite.ParseFromZeroCopyStream'>ParseFromZeroCopyStream()</a>, but accepts messages that are missing required fields. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>PROTOBUF_ATTRIBUTE_REINITIALIZES bool</code></td><td style="border-left-width: 0px"id="MessageLite.ParseFromFileDescriptor"><div style="padding-left: 16px; text-indent: -16px"><code><b>ParseFromFileDescriptor</b>(int file_descriptor)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Parse a protocol buffer from a file descriptor.  <a href="#MessageLite.ParseFromFileDescriptor.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>PROTOBUF_ATTRIBUTE_REINITIALIZES bool</code></td><td style="border-left-width: 0px"id="MessageLite.ParsePartialFromFileDescriptor"><div style="padding-left: 16px; text-indent: -16px"><code><b>ParsePartialFromFileDescriptor</b>(int file_descriptor)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Like <a href='#MessageLite.ParseFromFileDescriptor'>ParseFromFileDescriptor()</a>, but accepts messages that are missing required fields. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>PROTOBUF_ATTRIBUTE_REINITIALIZES bool</code></td><td style="border-left-width: 0px"id="MessageLite.ParseFromIstream"><div style="padding-left: 16px; text-indent: -16px"><code><b>ParseFromIstream</b>(std::istream * input)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Parse a protocol buffer from a C++ istream.  <a href="#MessageLite.ParseFromIstream.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>PROTOBUF_ATTRIBUTE_REINITIALIZES bool</code></td><td style="border-left-width: 0px"id="MessageLite.ParsePartialFromIstream"><div style="padding-left: 16px; text-indent: -16px"><code><b>ParsePartialFromIstream</b>(std::istream * input)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Like <a href='#MessageLite.ParseFromIstream'>ParseFromIstream()</a>, but accepts messages that are missing required fields. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="MessageLite.MergePartialFromBoundedZeroCopyStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>MergePartialFromBoundedZeroCopyStream</b>(<a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>io::ZeroCopyInputStream</a> * input, int size)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Read a protocol buffer from the given zero-copy input stream, expecting the message to be exactly "size" bytes long.  <a href="#MessageLite.MergePartialFromBoundedZeroCopyStream.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="MessageLite.MergeFromBoundedZeroCopyStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>MergeFromBoundedZeroCopyStream</b>(<a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>io::ZeroCopyInputStream</a> * input, int size)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Like ParseFromBoundedZeroCopyStream(), but accepts messages that are missing required fields. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>PROTOBUF_ATTRIBUTE_REINITIALIZES bool</code></td><td style="border-left-width: 0px"id="MessageLite.ParseFromBoundedZeroCopyStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>ParseFromBoundedZeroCopyStream</b>(<a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>io::ZeroCopyInputStream</a> * input, int size)</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>PROTOBUF_ATTRIBUTE_REINITIALIZES bool</code></td><td style="border-left-width: 0px"id="MessageLite.ParsePartialFromBoundedZeroCopyStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>ParsePartialFromBoundedZeroCopyStream</b>(<a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>io::ZeroCopyInputStream</a> * input, int size)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Like ParseFromBoundedZeroCopyStream(), but accepts messages that are missing required fields. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>PROTOBUF_ATTRIBUTE_REINITIALIZES bool</code></td><td style="border-left-width: 0px"id="MessageLite.ParseFromString"><div style="padding-left: 16px; text-indent: -16px"><code><b>ParseFromString</b>(ConstStringParam data)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Parses a protocol buffer contained in a string.  <a href="#MessageLite.ParseFromString.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>PROTOBUF_ATTRIBUTE_REINITIALIZES bool</code></td><td style="border-left-width: 0px"id="MessageLite.ParsePartialFromString"><div style="padding-left: 16px; text-indent: -16px"><code><b>ParsePartialFromString</b>(ConstStringParam data)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Like <a href='#MessageLite.ParseFromString'>ParseFromString()</a>, but accepts messages that are missing required fields. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>PROTOBUF_ATTRIBUTE_REINITIALIZES bool</code></td><td style="border-left-width: 0px"id="MessageLite.ParseFromArray"><div style="padding-left: 16px; text-indent: -16px"><code><b>ParseFromArray</b>(const void * data, int size)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Parse a protocol buffer contained in an array of bytes. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>PROTOBUF_ATTRIBUTE_REINITIALIZES bool</code></td><td style="border-left-width: 0px"id="MessageLite.ParsePartialFromArray"><div style="padding-left: 16px; text-indent: -16px"><code><b>ParsePartialFromArray</b>(const void * data, int size)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Like <a href='#MessageLite.ParseFromArray'>ParseFromArray()</a>, but accepts messages that are missing required fields. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="MessageLite.MergeFromCodedStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>MergeFromCodedStream</b>(<a href='google.protobuf.io.coded_stream#CodedInputStream'>io::CodedInputStream</a> * input)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Reads a protocol buffer from the stream and merges it into this <a href='google.protobuf.message#Message'>Message</a>.  <a href="#MessageLite.MergeFromCodedStream.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="MessageLite.MergePartialFromCodedStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>MergePartialFromCodedStream</b>(<a href='google.protobuf.io.coded_stream#CodedInputStream'>io::CodedInputStream</a> * input)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Like <a href='#MessageLite.MergeFromCodedStream'>MergeFromCodedStream()</a>, but succeeds even if required fields are missing in the input.  <a href="#MessageLite.MergePartialFromCodedStream.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="MessageLite.MergeFromString"><div style="padding-left: 16px; text-indent: -16px"><code><b>MergeFromString</b>(ConstStringParam data)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Merge a protocol buffer contained in a string. </div></td></tr><tr><th colspan="2"><h3 style="margin-top: 4px; margin-bottom: 4px;">Serialization</h3><div style="font-style: italic; font-weight: normal;">
<p>Methods for serializing in protocol buffer format.</p>

<p>Most of these are just simple wrappers around <a href='#MessageLite.ByteSize'>ByteSize()</a> and <a href='#MessageLite.SerializeWithCachedSizes'>SerializeWithCachedSizes()</a>. </p>
</div></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="MessageLite.SerializeToCodedStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>SerializeToCodedStream</b>(<a href='google.protobuf.io.coded_stream#CodedOutputStream'>io::CodedOutputStream</a> * output) const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Write a protocol buffer of this message to the given output.  <a href="#MessageLite.SerializeToCodedStream.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="MessageLite.SerializePartialToCodedStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>SerializePartialToCodedStream</b>(<a href='google.protobuf.io.coded_stream#CodedOutputStream'>io::CodedOutputStream</a> * output) const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Like <a href='#MessageLite.SerializeToCodedStream'>SerializeToCodedStream()</a>, but allows missing required fields. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="MessageLite.SerializeToZeroCopyStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>SerializeToZeroCopyStream</b>(<a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>io::ZeroCopyOutputStream</a> * output) const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Write the message to the given zero-copy output stream.  <a href="#MessageLite.SerializeToZeroCopyStream.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="MessageLite.SerializePartialToZeroCopyStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>SerializePartialToZeroCopyStream</b>(<a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>io::ZeroCopyOutputStream</a> * output) const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Like <a href='#MessageLite.SerializeToZeroCopyStream'>SerializeToZeroCopyStream()</a>, but allows missing required fields. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="MessageLite.SerializeToString"><div style="padding-left: 16px; text-indent: -16px"><code><b>SerializeToString</b>(std::string * output) const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Serialize the message and store it in the given string.  <a href="#MessageLite.SerializeToString.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="MessageLite.SerializePartialToString"><div style="padding-left: 16px; text-indent: -16px"><code><b>SerializePartialToString</b>(std::string * output) const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Like <a href='#MessageLite.SerializeToString'>SerializeToString()</a>, but allows missing required fields. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="MessageLite.SerializeToArray"><div style="padding-left: 16px; text-indent: -16px"><code><b>SerializeToArray</b>(void * data, int size) const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Serialize the message and store it in the given byte array.  <a href="#MessageLite.SerializeToArray.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="MessageLite.SerializePartialToArray"><div style="padding-left: 16px; text-indent: -16px"><code><b>SerializePartialToArray</b>(void * data, int size) const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Like <a href='#MessageLite.SerializeToArray'>SerializeToArray()</a>, but allows missing required fields. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>std::string</code></td><td style="border-left-width: 0px"id="MessageLite.SerializeAsString"><div style="padding-left: 16px; text-indent: -16px"><code><b>SerializeAsString</b>() const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Make a string encoding the message.  <a href="#MessageLite.SerializeAsString.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>std::string</code></td><td style="border-left-width: 0px"id="MessageLite.SerializePartialAsString"><div style="padding-left: 16px; text-indent: -16px"><code><b>SerializePartialAsString</b>() const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Like <a href='#MessageLite.SerializeAsString'>SerializeAsString()</a>, but allows missing required fields. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="MessageLite.SerializeToFileDescriptor"><div style="padding-left: 16px; text-indent: -16px"><code><b>SerializeToFileDescriptor</b>(int file_descriptor) const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Serialize the message and write it to the given file descriptor.  <a href="#MessageLite.SerializeToFileDescriptor.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="MessageLite.SerializePartialToFileDescriptor"><div style="padding-left: 16px; text-indent: -16px"><code><b>SerializePartialToFileDescriptor</b>(int file_descriptor) const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Like <a href='#MessageLite.SerializeToFileDescriptor'>SerializeToFileDescriptor()</a>, but allows missing required fields. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="MessageLite.SerializeToOstream"><div style="padding-left: 16px; text-indent: -16px"><code><b>SerializeToOstream</b>(std::ostream * output) const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Serialize the message and write it to the given C++ ostream.  <a href="#MessageLite.SerializeToOstream.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="MessageLite.SerializePartialToOstream"><div style="padding-left: 16px; text-indent: -16px"><code><b>SerializePartialToOstream</b>(std::ostream * output) const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Like <a href='#MessageLite.SerializeToOstream'>SerializeToOstream()</a>, but allows missing required fields. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="MessageLite.AppendToString"><div style="padding-left: 16px; text-indent: -16px"><code><b>AppendToString</b>(std::string * output) const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Like <a href='#MessageLite.SerializeToString'>SerializeToString()</a>, but appends to the data to the string's existing contents.  <a href="#MessageLite.AppendToString.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="MessageLite.AppendPartialToString"><div style="padding-left: 16px; text-indent: -16px"><code><b>AppendPartialToString</b>(std::string * output) const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Like <a href='#MessageLite.AppendToString'>AppendToString()</a>, but allows missing required fields. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual size_t</code></td><td style="border-left-width: 0px"id="MessageLite.ByteSizeLong"><div style="padding-left: 16px; text-indent: -16px"><code><b>ByteSizeLong</b>() const  = 0</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Computes the serialized size of the message.  <a href="#MessageLite.ByteSizeLong.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>int</code></td><td style="border-left-width: 0px"id="MessageLite.ByteSize"><div style="padding-left: 16px; text-indent: -16px"><code><b>ByteSize</b>() const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Legacy <a href='#MessageLite.ByteSize'>ByteSize()</a> API. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="MessageLite.SerializeWithCachedSizes"><div style="padding-left: 16px; text-indent: -16px"><code><b>SerializeWithCachedSizes</b>(<a href='google.protobuf.io.coded_stream#CodedOutputStream'>io::CodedOutputStream</a> * output) const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Serializes the message without recomputing the size.  <a href="#MessageLite.SerializeWithCachedSizes.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>uint8 *</code></td><td style="border-left-width: 0px"id="MessageLite.SerializeWithCachedSizesToArray"><div style="padding-left: 16px; text-indent: -16px"><code><b>SerializeWithCachedSizesToArray</b>(uint8 * target) const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Like SerializeWithCachedSizes, but writes directly to *target, returning a pointer to the byte immediately after the last byte written.  <a href="#MessageLite.SerializeWithCachedSizesToArray.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual int</code></td><td style="border-left-width: 0px"id="MessageLite.GetCachedSize"><div style="padding-left: 16px; text-indent: -16px"><code><b>GetCachedSize</b>() const  = 0</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Returns the result of the last call to <a href='#MessageLite.ByteSize'>ByteSize()</a>.  <a href="#MessageLite.GetCachedSize.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual const char *</code></td><td style="border-left-width: 0px"id="MessageLite._InternalParse"><div style="padding-left: 16px; text-indent: -16px"><code><b>_InternalParse</b>(const char * , internal::ParseContext * )</code></div></td></tr></table> <hr><h3 id="MessageLite.ParseFlags.details"><code>enum MessageLite::ParseFlags {<br>&nbsp;&nbsp;kMerge = = 0,<br>&nbsp;&nbsp;kParse = = 1,<br>&nbsp;&nbsp;kMergePartial = = 2,<br>&nbsp;&nbsp;kParsePartial = = 3,<br>&nbsp;&nbsp;kMergeWithAliasing = = 4,<br>&nbsp;&nbsp;kParseWithAliasing = = 5,<br>&nbsp;&nbsp;kMergePartialWithAliasing = = 6,<br>&nbsp;&nbsp;kParsePartialWithAliasing = = 7<br>}</code></h3><div style="margin-left: 16px"><p></p><table><tr><td>kMerge</td><td></td></tr><tr><td>kParse</td><td></td></tr><tr><td>kMergePartial</td><td></td></tr><tr><td>kParsePartial</td><td></td></tr><tr><td>kMergeWithAliasing</td><td></td></tr><tr><td>kParseWithAliasing</td><td></td></tr><tr><td>kMergePartialWithAliasing</td><td></td></tr><tr><td>kParsePartialWithAliasing</td><td></td></tr></table></div> <hr><h3 id="MessageLite._InternalSerialize.details"><code>virtual uint8 * MessageLite::_InternalSerialize(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint8 * ptr,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='google.protobuf.io.coded_stream#EpsCopyOutputStream'>io::EpsCopyOutputStream</a> * stream) const  = 0</code></h3><div style="margin-left: 16px"><p>Fast path when conditions match (ie. </p><p>non-deterministic) uint8* _InternalSerialize(uint8* ptr) const; </p>
</div> <hr><h3 id="MessageLite.GetOwningArena.details"><code>protected <a href='google.protobuf.arena#Arena'>Arena</a> * MessageLite::GetOwningArena() const</code></h3><div style="margin-left: 16px"><p>Returns the arena, if any, that directly owns this message and its internal memory (<a href='google.protobuf.arena#Arena.Own'>Arena::Own</a> is different in that the arena doesn't directly own the internal memory). </p><p>This method is used in proto's implementation for swapping, moving and setting allocated, for deciding whether the ownership of this message or its internal memory could be changed. </p>
</div> <hr><h3 id="MessageLite.New.details"><code>virtual <a href='#MessageLite'>MessageLite</a> * MessageLite::New() const  = 0</code></h3><div style="margin-left: 16px"><p>Construct a new instance of the same type. </p><p>Ownership is passed to the caller. </p>
</div> <hr><h3 id="MessageLite.New.details"><code>virtual <a href='#MessageLite'>MessageLite</a> * MessageLite::New(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='google.protobuf.arena#Arena'>Arena</a> * arena) const</code></h3><div style="margin-left: 16px"><p>Construct a new instance on the arena. </p><p>Ownership is passed to the caller if arena is a NULL. Default implementation for backwards compatibility. </p>
</div> <hr><h3 id="MessageLite.GetMaybeArenaPointer.details"><code>void * MessageLite::GetMaybeArenaPointer() const</code></h3><div style="margin-left: 16px"><p>Get a pointer that may be equal to this message's arena, or may not be. </p><p>If the value returned by this method is equal to some arena pointer, then this message is on that arena; however, if this message is on some arena, this method may or may not return that arena's pointer. As a tradeoff, this method may be more efficient than <a href='#MessageLite.GetArena'>GetArena()</a>. The intent is to allow underlying representations that use e.g. tagged pointers to sometimes store the arena pointer directly, and sometimes in a more indirect way, and allow a fastpath comparison against the arena pointer when it's easy to obtain. </p>
</div> <hr><h3 id="MessageLite.Clear.details"><code>virtual void MessageLite::Clear()  = 0</code></h3><div style="margin-left: 16px"><p>Clear all fields of the message and set them to their default values. </p><p><a href='#MessageLite.Clear'>Clear()</a> avoids freeing memory, assuming that any memory allocated to hold parts of the message will be needed again to hold the next message. If you actually want to free the memory used by a <a href='google.protobuf.message#Message'>Message</a>, you must delete it. </p>
</div> <hr><h3 id="MessageLite.InitializationErrorString.details"><code>virtual std::string MessageLite::InitializationErrorString() const</code></h3><div style="margin-left: 16px"><p>This is not implemented for Lite messages &ndash; it just returns "(cannot
determine missing fields for lite message)". </p><p>However, it is implemented for full messages. See <a href='google.protobuf.message'>message.h</a>. </p>
</div> <hr><h3 id="MessageLite.CheckTypeAndMergeFrom.details"><code>virtual void MessageLite::CheckTypeAndMergeFrom(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const <a href='#MessageLite'>MessageLite</a> &amp; other)  = 0</code></h3><div style="margin-left: 16px"><p>If |other| is the exact same class as this, calls MergeFrom(). </p><p>Otherwise, results are undefined (probably crash). </p>
</div> <hr><h3 id="MessageLite.DebugString.details"><code>std::string MessageLite::DebugString() const</code></h3><div style="margin-left: 16px"><p>These methods return a human-readable summary of the message. </p><p>Note that since the <a href='#MessageLite'>MessageLite</a> interface does not support reflection, there is very little information that these methods can provide. They are shadowed by methods of the same name on the <a href='google.protobuf.message#Message'>Message</a> interface which provide much more information. The methods here are intended primarily to facilitate code reuse for logic that needs to interoperate with both full and lite protos.</p>

<p>The format of the returned string is subject to change, so please do not assume it will remain stable over time. </p>
</div> <hr><h3 id="MessageLite.Utf8DebugString.details"><code>std::string MessageLite::Utf8DebugString() const</code></h3><div style="margin-left: 16px"><p><a href='#MessageLite.DebugString'>MessageLite::DebugString</a> is already Utf8 Safe. </p><p>This is to add compatibility with <a href='google.protobuf.message#Message'>Message</a>. </p>
</div> <hr><h3 id="MessageLite.ParseFromCodedStream.details"><code>PROTOBUF_ATTRIBUTE_REINITIALIZES bool <br>&nbsp;&nbsp;&nbsp;&nbsp;MessageLite::ParseFromCodedStream(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='google.protobuf.io.coded_stream#CodedInputStream'>io::CodedInputStream</a> * input)</code></h3><div style="margin-left: 16px"><p>Fill the message with a protocol buffer parsed from the given input stream. </p><p>Returns false on a read error or if the input is in the wrong format. A successful return does not indicate the entire input is consumed, ensure you call ConsumedEntireMessage() to check that if applicable. </p>
</div> <hr><h3 id="MessageLite.ParseFromZeroCopyStream.details"><code>PROTOBUF_ATTRIBUTE_REINITIALIZES bool <br>&nbsp;&nbsp;&nbsp;&nbsp;MessageLite::ParseFromZeroCopyStream(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>io::ZeroCopyInputStream</a> * input)</code></h3><div style="margin-left: 16px"><p>Read a protocol buffer from the given zero-copy input stream. </p><p>If successful, the entire input will be consumed. </p>
</div> <hr><h3 id="MessageLite.ParseFromFileDescriptor.details"><code>PROTOBUF_ATTRIBUTE_REINITIALIZES bool <br>&nbsp;&nbsp;&nbsp;&nbsp;MessageLite::ParseFromFileDescriptor(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int file_descriptor)</code></h3><div style="margin-left: 16px"><p>Parse a protocol buffer from a file descriptor. </p><p>If successful, the entire input will be consumed. </p>
</div> <hr><h3 id="MessageLite.ParseFromIstream.details"><code>PROTOBUF_ATTRIBUTE_REINITIALIZES bool <br>&nbsp;&nbsp;&nbsp;&nbsp;MessageLite::ParseFromIstream(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::istream * input)</code></h3><div style="margin-left: 16px"><p>Parse a protocol buffer from a C++ istream. </p><p>If successful, the entire input will be consumed. </p>
</div> <hr><h3 id="MessageLite.MergePartialFromBoundedZeroCopyStream.details"><code>bool MessageLite::MergePartialFromBoundedZeroCopyStream(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>io::ZeroCopyInputStream</a> * input,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int size)</code></h3><div style="margin-left: 16px"><p>Read a protocol buffer from the given zero-copy input stream, expecting the message to be exactly "size" bytes long. </p><p>If successful, exactly this many bytes will have been consumed from the input. </p>
</div> <hr><h3 id="MessageLite.ParseFromString.details"><code>PROTOBUF_ATTRIBUTE_REINITIALIZES bool <br>&nbsp;&nbsp;&nbsp;&nbsp;MessageLite::ParseFromString(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConstStringParam data)</code></h3><div style="margin-left: 16px"><p>Parses a protocol buffer contained in a string. </p><p>Returns true on success. This function takes a string in the (non-human-readable) binary wire format, matching the encoding output by <a href='#MessageLite.SerializeToString'>MessageLite::SerializeToString()</a>. If you'd like to convert a human-readable string into a protocol buffer object, see <a href='google.protobuf.text_format#TextFormat.ParseFromString'>google::protobuf::TextFormat::ParseFromString()</a>. </p>
</div> <hr><h3 id="MessageLite.MergeFromCodedStream.details"><code>bool MessageLite::MergeFromCodedStream(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='google.protobuf.io.coded_stream#CodedInputStream'>io::CodedInputStream</a> * input)</code></h3><div style="margin-left: 16px"><p>Reads a protocol buffer from the stream and merges it into this <a href='google.protobuf.message#Message'>Message</a>. </p><p>Singular fields read from the what is already in the <a href='google.protobuf.message#Message'>Message</a> and repeated fields are appended to those already present.</p>

<p>It is the responsibility of the caller to call input-&gt;LastTagWas() (for groups) or input-&gt;ConsumedEntireMessage() (for non-groups) after this returns to verify that the message's end was delimited correctly.</p>

<p><a href='#MessageLite.ParseFromCodedStream'>ParseFromCodedStream()</a> is implemented as <a href='#MessageLite.Clear'>Clear()</a> followed by <a href='#MessageLite.MergeFromCodedStream'>MergeFromCodedStream()</a>. </p>
</div> <hr><h3 id="MessageLite.MergePartialFromCodedStream.details"><code>bool MessageLite::MergePartialFromCodedStream(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='google.protobuf.io.coded_stream#CodedInputStream'>io::CodedInputStream</a> * input)</code></h3><div style="margin-left: 16px"><p>Like <a href='#MessageLite.MergeFromCodedStream'>MergeFromCodedStream()</a>, but succeeds even if required fields are missing in the input. </p><p><a href='#MessageLite.MergeFromCodedStream'>MergeFromCodedStream()</a> is just implemented as <a href='#MessageLite.MergePartialFromCodedStream'>MergePartialFromCodedStream()</a> followed by <a href='#MessageLite.IsInitialized'>IsInitialized()</a>. </p>
</div> <hr><h3 id="MessageLite.SerializeToCodedStream.details"><code>bool MessageLite::SerializeToCodedStream(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='google.protobuf.io.coded_stream#CodedOutputStream'>io::CodedOutputStream</a> * output) const</code></h3><div style="margin-left: 16px"><p>Write a protocol buffer of this message to the given output. </p><p>Returns false on a write error. If the message is missing required fields, this may GOOGLE_CHECK-fail. </p>
</div> <hr><h3 id="MessageLite.SerializeToZeroCopyStream.details"><code>bool MessageLite::SerializeToZeroCopyStream(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>io::ZeroCopyOutputStream</a> * output) const</code></h3><div style="margin-left: 16px"><p>Write the message to the given zero-copy output stream. </p><p>All required fields must be set. </p>
</div> <hr><h3 id="MessageLite.SerializeToString.details"><code>bool MessageLite::SerializeToString(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::string * output) const</code></h3><div style="margin-left: 16px"><p>Serialize the message and store it in the given string. </p><p>All required fields must be set. </p>
</div> <hr><h3 id="MessageLite.SerializeToArray.details"><code>bool MessageLite::SerializeToArray(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void * data,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int size) const</code></h3><div style="margin-left: 16px"><p>Serialize the message and store it in the given byte array. </p><p>All required fields must be set. </p>
</div> <hr><h3 id="MessageLite.SerializeAsString.details"><code>std::string MessageLite::SerializeAsString() const</code></h3><div style="margin-left: 16px"><p>Make a string encoding the message. </p><p>Is equivalent to calling <a href='#MessageLite.SerializeToString'>SerializeToString()</a> on a string and using that. Returns the empty string if <a href='#MessageLite.SerializeToString'>SerializeToString()</a> would have returned an error. Note: If you intend to generate many such strings, you may reduce heap fragmentation by instead re-using the same string object with calls to <a href='#MessageLite.SerializeToString'>SerializeToString()</a>. </p>
</div> <hr><h3 id="MessageLite.SerializeToFileDescriptor.details"><code>bool MessageLite::SerializeToFileDescriptor(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int file_descriptor) const</code></h3><div style="margin-left: 16px"><p>Serialize the message and write it to the given file descriptor. </p><p>All required fields must be set. </p>
</div> <hr><h3 id="MessageLite.SerializeToOstream.details"><code>bool MessageLite::SerializeToOstream(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::ostream * output) const</code></h3><div style="margin-left: 16px"><p>Serialize the message and write it to the given C++ ostream. </p><p>All required fields must be set. </p>
</div> <hr><h3 id="MessageLite.AppendToString.details"><code>bool MessageLite::AppendToString(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::string * output) const</code></h3><div style="margin-left: 16px"><p>Like <a href='#MessageLite.SerializeToString'>SerializeToString()</a>, but appends to the data to the string's existing contents. </p><p>All required fields must be set. </p>
</div> <hr><h3 id="MessageLite.ByteSizeLong.details"><code>virtual size_t MessageLite::ByteSizeLong() const  = 0</code></h3><div style="margin-left: 16px"><p>Computes the serialized size of the message. </p><p>This recursively calls <a href='#MessageLite.ByteSizeLong'>ByteSizeLong()</a> on all embedded messages.</p>

<p><a href='#MessageLite.ByteSizeLong'>ByteSizeLong()</a> is generally linear in the number of fields defined for the proto. </p>
</div> <hr><h3 id="MessageLite.SerializeWithCachedSizes.details"><code>void MessageLite::SerializeWithCachedSizes(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='google.protobuf.io.coded_stream#CodedOutputStream'>io::CodedOutputStream</a> * output) const</code></h3><div style="margin-left: 16px"><p>Serializes the message without recomputing the size. </p><p>The message must not have changed since the last call to <a href='#MessageLite.ByteSize'>ByteSize()</a>, and the value returned by ByteSize must be non-negative. Otherwise the results are undefined. </p>
</div> <hr><h3 id="MessageLite.SerializeWithCachedSizesToArray.details"><code>uint8 * MessageLite::SerializeWithCachedSizesToArray(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint8 * target) const</code></h3><div style="margin-left: 16px"><p>Like SerializeWithCachedSizes, but writes directly to *target, returning a pointer to the byte immediately after the last byte written. </p><p>"target" must point at a byte array of at least <a href='#MessageLite.ByteSize'>ByteSize()</a> bytes. Whether to use deterministic serialization, e.g., maps in sorted order, is determined by CodedOutputStream::IsDefaultSerializationDeterministic(). </p>
</div> <hr><h3 id="MessageLite.GetCachedSize.details"><code>virtual int MessageLite::GetCachedSize() const  = 0</code></h3><div style="margin-left: 16px"><p>Returns the result of the last call to <a href='#MessageLite.ByteSize'>ByteSize()</a>. </p><p>An embedded message's size is needed both to serialize it (because embedded messages are length-delimited) and to compute the outer message's size. Caching the size avoids computing it multiple times.</p>

<p><a href='#MessageLite.ByteSize'>ByteSize()</a> does not automatically use the cached size when available because this would require invalidating it every time the message was modified, which would be too hard and expensive. (E.g. if a deeply-nested sub-message is changed, all of its parents' cached sizes would need to be invalidated, which is too much work for an otherwise inlined setter method.) </p>

</div>
