+++
title = "printer.h"
toc_hide = "true"
linkTitle = "C++"
description = "This section contains reference documentation for working with protocol buffer classes in C++."
type = "docs"
+++

<p><code>#include &lt;google/protobuf/io/printer.h&gt;<br>namespace <a href="#google.protobuf.io">google::protobuf::io</a></code></p><p>Utility class for writing text to a <a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a>. </p><table width="100%"><tr><th colspan="2"><h3 style="margin-top: 4px">Classes in this file</h3></th></tr><tr><td><div><code><a href="#AnnotationCollector">AnnotationCollector</a></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Records annotations about a <a href='#Printer'>Printer</a>'s output. </div></td></tr><tr><td><div><code><a href="#AnnotationProtoCollector">AnnotationProtoCollector</a></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Records annotations about a <a href='#Printer'>Printer</a>'s output to the given protocol buffer, assuming that the buffer has an ::Annotation message exposing path, source_file, begin and end fields. </div></td></tr><tr><td><div><code><a href="#Printer">Printer</a></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;"></div></td></tr></table><h2 id="AnnotationCollector">class AnnotationCollector</h2><p><code>#include &lt;<a href="#">google/protobuf/io/printer.h</a>&gt;<br>namespace <a href="#google.protobuf.io">google::protobuf::io</a></code></p><p>Records annotations about a <a href='#Printer'>Printer</a>'s output. </p><p>Known subclasses:</p><ul><li><code><a href="#AnnotationProtoCollector">AnnotationProtoCollector< AnnotationProto ></a></code></li></ul><table><tr><th colspan="2"><h3 style="margin-top: 4px">Members</h3></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>typedef</code></td><td style="border-left-width: 0px"id="AnnotationCollector.Annotation"><div style="padding-left: 16px; text-indent: -16px"><code>std::pair&lt; std::pair&lt; size_t, size_t &gt;, std::string &gt; <b>Annotation</b></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Annotation is a offset range and a payload pair. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual void</code></td><td style="border-left-width: 0px"id="AnnotationCollector.AddAnnotation"><div style="padding-left: 16px; text-indent: -16px"><code><b>AddAnnotation</b>(size_t begin_offset, size_t end_offset, const std::string &amp; file_path, const std::vector&lt; int &gt; &amp; path)  = 0</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Records that the bytes in file_path beginning with begin_offset and ending before end_offset are associated with the SourceCodeInfo-style path. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual void</code></td><td style="border-left-width: 0px"id="AnnotationCollector.AddAnnotationNew"><div style="padding-left: 16px; text-indent: -16px"><code><b>AddAnnotationNew</b>(<a href='#AnnotationCollector.Annotation'>Annotation</a> &amp; )</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;"><a href="#AnnotationCollector.AddAnnotationNew.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual </code></td><td style="border-left-width: 0px"id="AnnotationCollector.~AnnotationCollector"><div style="padding-left: 16px; text-indent: -16px"><code><b>~AnnotationCollector</b>()</code></div></td></tr></table> <hr><h3 id="AnnotationCollector.AddAnnotationNew.details"><code>virtual void AnnotationCollector::AddAnnotationNew(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#AnnotationCollector.Annotation'>Annotation</a> &amp; )</code></h3><div style="margin-left: 16px"><p></p><p>Just a vector of range, payload pairs stored in a context should suffice. </p>

</div><h2 id="AnnotationProtoCollector">template class AnnotationProtoCollector: public <a href="#AnnotationCollector">AnnotationCollector</a></h2><p><code>#include &lt;<a href="#">google/protobuf/io/printer.h</a>&gt;<br>namespace <a href="#google.protobuf.io">google::protobuf::io</a><br><br>template &lt;typename &gt;</code></p><p>Records annotations about a <a href='#Printer'>Printer</a>'s output to the given protocol buffer, assuming that the buffer has an ::Annotation message exposing path, source_file, begin and end fields. </p><table><tr><th colspan="2"><h3 style="margin-top: 4px">Members</h3></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>explicit </code></td><td style="border-left-width: 0px"id="AnnotationProtoCollector.AnnotationProtoCollector"><div style="padding-left: 16px; text-indent: -16px"><code><b>AnnotationProtoCollector</b>(AnnotationProto * annotation_proto)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">annotation_proto is the protocol buffer to which new Annotations should be added.  <a href="#AnnotationProtoCollector.AnnotationProtoCollector.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual void</code></td><td style="border-left-width: 0px"id="AnnotationProtoCollector.AddAnnotation"><div style="padding-left: 16px; text-indent: -16px"><code><b>AddAnnotation</b>(size_t begin_offset, size_t end_offset, const std::string &amp; file_path, const std::vector&lt; int &gt; &amp; path)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Override for <a href='#AnnotationCollector.AddAnnotation'>AnnotationCollector::AddAnnotation</a>. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual void</code></td><td style="border-left-width: 0px"id="AnnotationProtoCollector.AddAnnotationNew"><div style="padding-left: 16px; text-indent: -16px"><code><b>AddAnnotationNew</b>(<a href='#AnnotationCollector.Annotation'>Annotation</a> &amp; a)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Override for <a href='#AnnotationCollector.AddAnnotation'>AnnotationCollector::AddAnnotation</a>. </div></td></tr></table> <hr><h3 id="AnnotationProtoCollector.AnnotationProtoCollector.details"><code>explicit  AnnotationProtoCollector::AnnotationProtoCollector(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AnnotationProto * annotation_proto)</code></h3><div style="margin-left: 16px"><p>annotation_proto is the protocol buffer to which new Annotations should be added. </p><p>It is not owned by the <a href='#AnnotationProtoCollector'>AnnotationProtoCollector</a>. </p>
</div><h2 id="Printer">class Printer</h2><p><code>#include &lt;<a href="#">google/protobuf/io/printer.h</a>&gt;<br>namespace <a href="#google.protobuf.io">google::protobuf::io</a></code></p><p></p><table><tr><th colspan="2"><h3 style="margin-top: 4px">Members</h3></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="Printer.Printer"><div style="padding-left: 16px; text-indent: -16px"><code><b>Printer</b>(<a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a> * output, char variable_delimiter)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Create a printer that writes text to the given output stream.  <a href="#Printer.Printer.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="Printer.Printer"><div style="padding-left: 16px; text-indent: -16px"><code><b>Printer</b>(<a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a> * output, char variable_delimiter, <a href='#AnnotationCollector'>AnnotationCollector</a> * annotation_collector)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Create a printer that writes text to the given output stream.  <a href="#Printer.Printer.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="Printer.~Printer"><div style="padding-left: 16px; text-indent: -16px"><code><b>~Printer</b>()</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>template void</code></td><td style="border-left-width: 0px"id="Printer.Annotate"><div style="padding-left: 16px; text-indent: -16px"><code><b>Annotate</b>(const char * varname, const SomeDescriptor * descriptor)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Link a substitution variable emitted by the last call to Print to the object described by descriptor. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>template void</code></td><td style="border-left-width: 0px"id="Printer.Annotate"><div style="padding-left: 16px; text-indent: -16px"><code><b>Annotate</b>(const char * begin_varname, const char * end_varname, const SomeDescriptor * descriptor)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Link the output range defined by the substitution variables as emitted by the last call to Print to the object described by descriptor.  <a href="#Printer.Annotate.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="Printer.Annotate"><div style="padding-left: 16px; text-indent: -16px"><code><b>Annotate</b>(const char * varname, const std::string &amp; file_name)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Link a substitution variable emitted by the last call to Print to the file with path file_name. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="Printer.Annotate"><div style="padding-left: 16px; text-indent: -16px"><code><b>Annotate</b>(const char * begin_varname, const char * end_varname, const std::string &amp; file_name)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Link the output range defined by the substitution variables as emitted by the last call to Print to the file with path file_name.  <a href="#Printer.Annotate.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="Printer.Print"><div style="padding-left: 16px; text-indent: -16px"><code><b>Print</b>(const std::map&lt; std::string, std::string &gt; &amp; variables, const char * text)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Print some text after applying variable substitutions.  <a href="#Printer.Print.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>template void</code></td><td style="border-left-width: 0px"id="Printer.Print"><div style="padding-left: 16px; text-indent: -16px"><code><b>Print</b>(const char * text, const Args &amp;... args)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Like the first <a href='#Printer.Print'>Print()</a>, except the substitutions are given as parameters. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="Printer.Indent"><div style="padding-left: 16px; text-indent: -16px"><code><b>Indent</b>()</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Indent text by two spaces.  <a href="#Printer.Indent.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="Printer.Outdent"><div style="padding-left: 16px; text-indent: -16px"><code><b>Outdent</b>()</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Reduces the current indent level by two spaces, or crashes if the indent level is zero. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="Printer.PrintRaw"><div style="padding-left: 16px; text-indent: -16px"><code><b>PrintRaw</b>(const std::string &amp; data)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Write a string to the output buffer.  <a href="#Printer.PrintRaw.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="Printer.PrintRaw"><div style="padding-left: 16px; text-indent: -16px"><code><b>PrintRaw</b>(const char * data)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Write a zero-delimited string to output buffer.  <a href="#Printer.PrintRaw.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="Printer.WriteRaw"><div style="padding-left: 16px; text-indent: -16px"><code><b>WriteRaw</b>(const char * data, int size)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Write some bytes to the output buffer.  <a href="#Printer.WriteRaw.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="Printer.FormatInternal"><div style="padding-left: 16px; text-indent: -16px"><code><b>FormatInternal</b>(const std::vector&lt; std::string &gt; &amp; args, const std::map&lt; std::string, std::string &gt; &amp; vars, const char * format)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">FormatInternal is a helper function not meant to use directly, use compiler::cpp::Formatter instead.  <a href="#Printer.FormatInternal.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="Printer.failed"><div style="padding-left: 16px; text-indent: -16px"><code><b>failed</b>() const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">True if any write to the underlying stream failed.  <a href="#Printer.failed.details">more...</a></div></td></tr></table> <hr><h3 id="Printer.Printer.details"><code> Printer::Printer(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a> * output,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char variable_delimiter)</code></h3><div style="margin-left: 16px"><p>Create a printer that writes text to the given output stream. </p><p>Use the given character as the delimiter for variables. </p>
</div> <hr><h3 id="Printer.Printer.details"><code> Printer::Printer(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a> * output,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char variable_delimiter,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#AnnotationCollector'>AnnotationCollector</a> * annotation_collector)</code></h3><div style="margin-left: 16px"><p>Create a printer that writes text to the given output stream. </p><p>Use the given character as the delimiter for variables. If annotation_collector is not null, <a href='#Printer'>Printer</a> will provide it with annotations about code written to the stream. annotation_collector is not owned by <a href='#Printer'>Printer</a>. </p>
</div> <hr><h3 id="Printer.Annotate.details"><code>template void Printer::Annotate(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char * begin_varname,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char * end_varname,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const SomeDescriptor * descriptor)</code></h3><div style="margin-left: 16px"><p>Link the output range defined by the substitution variables as emitted by the last call to Print to the object described by descriptor. </p><p>The range begins at begin_varname's value and ends after the last character of the value substituted for end_varname. </p>
</div> <hr><h3 id="Printer.Annotate.details"><code>void Printer::Annotate(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char * begin_varname,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char * end_varname,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string &amp; file_name)</code></h3><div style="margin-left: 16px"><p>Link the output range defined by the substitution variables as emitted by the last call to Print to the file with path file_name. </p><p>The range begins at begin_varname's value and ends after the last character of the value substituted for end_varname. </p>
</div> <hr><h3 id="Printer.Print.details"><code>void Printer::Print(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::map&lt; std::string, std::string &gt; &amp; variables,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char * text)</code></h3><div style="margin-left: 16px"><p>Print some text after applying variable substitutions. </p><p>If a particular variable in the text is not defined, this will crash. Variables to be substituted are identified by their names surrounded by delimiter characters (as given to the constructor). The variable bindings are defined by the given map. </p>
</div> <hr><h3 id="Printer.Indent.details"><code>void Printer::Indent()</code></h3><div style="margin-left: 16px"><p>Indent text by two spaces. </p><p>After calling <a href='#Printer.Indent'>Indent()</a>, two spaces will be inserted at the beginning of each line of text. <a href='#Printer.Indent'>Indent()</a> may be called multiple times to produce deeper indents. </p>
</div> <hr><h3 id="Printer.PrintRaw.details"><code>void Printer::PrintRaw(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string &amp; data)</code></h3><div style="margin-left: 16px"><p>Write a string to the output buffer. </p><p>This method does not look for newlines to add indentation. </p>
</div> <hr><h3 id="Printer.PrintRaw.details"><code>void Printer::PrintRaw(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char * data)</code></h3><div style="margin-left: 16px"><p>Write a zero-delimited string to output buffer. </p><p>This method does not look for newlines to add indentation. </p>
</div> <hr><h3 id="Printer.WriteRaw.details"><code>void Printer::WriteRaw(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char * data,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int size)</code></h3><div style="margin-left: 16px"><p>Write some bytes to the output buffer. </p><p>This method does not look for newlines to add indentation. </p>
</div> <hr><h3 id="Printer.FormatInternal.details"><code>void Printer::FormatInternal(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt; std::string &gt; &amp; args,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::map&lt; std::string, std::string &gt; &amp; vars,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char * format)</code></h3><div style="margin-left: 16px"><p>FormatInternal is a helper function not meant to use directly, use compiler::cpp::Formatter instead. </p><p>This function is meant to support formatting text using named variables (eq. "$foo$) from a lookup map (vars)
and variables directly supplied by arguments (eq "$1$" meaning first argument which is the zero index element of args). </p>
</div> <hr><h3 id="Printer.failed.details"><code>bool Printer::failed() const</code></h3><div style="margin-left: 16px"><p>True if any write to the underlying stream failed. </p><p>(We don't just crash in this case because this is an I/O failure, not a programming error.) </p>
</div>
