+++
title = "importer.h"
toc_hide = "true"
linkTitle = "C++"
description = "This section contains reference documentation for working with protocol buffer classes in C++."
type = "docs"
+++

<p><code>#include &lt;google/protobuf/compiler/importer.h&gt;<br>namespace <a href="#google.protobuf.compiler">google::protobuf::compiler</a></code></p><p>This file is the public interface to the .proto file parser. </p><table width="100%"><tr><th colspan="2"><h3 style="margin-top: 4px">Classes in this file</h3></th></tr><tr><td><div><code><a href="#SourceTreeDescriptorDatabase">SourceTreeDescriptorDatabase</a></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">An implementation of <a href='google.protobuf.descriptor_database#DescriptorDatabase'>DescriptorDatabase</a> which loads files from a <a href='#SourceTree'>SourceTree</a> and parses them. </div></td></tr><tr><td><div><code><a href="#Importer">Importer</a></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Simple interface for parsing .proto files. </div></td></tr><tr><td><div><code><a href="#MultiFileErrorCollector">MultiFileErrorCollector</a></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">If the importer encounters problems while trying to import the proto files, it reports them to a <a href='#MultiFileErrorCollector'>MultiFileErrorCollector</a>. </div></td></tr><tr><td><div><code><a href="#SourceTree">SourceTree</a></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Abstract interface which represents a directory tree containing proto files. </div></td></tr><tr><td><div><code><a href="#DiskSourceTree">DiskSourceTree</a></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">An implementation of <a href='#SourceTree'>SourceTree</a> which loads files from locations on disk. </div></td></tr></table><h2 id="SourceTreeDescriptorDatabase">class SourceTreeDescriptorDatabase: public <a href="google.protobuf.descriptor_database#DescriptorDatabase">DescriptorDatabase</a></h2><p><code>#include &lt;<a href="#">google/protobuf/compiler/importer.h</a>&gt;<br>namespace <a href="#google.protobuf.compiler">google::protobuf::compiler</a></code></p><p>An implementation of <a href='google.protobuf.descriptor_database#DescriptorDatabase'>DescriptorDatabase</a> which loads files from a <a href='#SourceTree'>SourceTree</a> and parses them. </p><p>Note: This class is not thread-safe since it maintains a table of source code locations for error reporting. However, when a <a href='google.protobuf.descriptor#DescriptorPool'>DescriptorPool</a> wraps a <a href='google.protobuf.descriptor_database#DescriptorDatabase'>DescriptorDatabase</a>, it uses mutex locking to make sure only one method of the database is called at a time, even if the <a href='google.protobuf.descriptor#DescriptorPool'>DescriptorPool</a> is used from multiple threads. Therefore, there is only a problem if you create multiple DescriptorPools wrapping the same <a href='#SourceTreeDescriptorDatabase'>SourceTreeDescriptorDatabase</a> and use them from multiple threads.</p>

<p>Note: This class does not implement <a href='#SourceTreeDescriptorDatabase.FindFileContainingSymbol'>FindFileContainingSymbol()</a> or <a href='#SourceTreeDescriptorDatabase.FindFileContainingExtension'>FindFileContainingExtension()</a>; these will always return false. </p>

<table><tr><th colspan="2"><h3 style="margin-top: 4px">Members</h3></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="SourceTreeDescriptorDatabase.SourceTreeDescriptorDatabase"><div style="padding-left: 16px; text-indent: -16px"><code><b>SourceTreeDescriptorDatabase</b>(<a href='#SourceTree'>SourceTree</a> * source_tree)</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="SourceTreeDescriptorDatabase.SourceTreeDescriptorDatabase"><div style="padding-left: 16px; text-indent: -16px"><code><b>SourceTreeDescriptorDatabase</b>(<a href='#SourceTree'>SourceTree</a> * source_tree, <a href='google.protobuf.descriptor_database#DescriptorDatabase'>DescriptorDatabase</a> * fallback_database)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">If non-NULL, fallback_database will be checked if a file doesn't exist in the specified source_tree. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="SourceTreeDescriptorDatabase.~SourceTreeDescriptorDatabase"><div style="padding-left: 16px; text-indent: -16px"><code><b>~SourceTreeDescriptorDatabase</b>()</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="SourceTreeDescriptorDatabase.RecordErrorsTo"><div style="padding-left: 16px; text-indent: -16px"><code><b>RecordErrorsTo</b>(<a href='#MultiFileErrorCollector'>MultiFileErrorCollector</a> * error_collector)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Instructs the <a href='#SourceTreeDescriptorDatabase'>SourceTreeDescriptorDatabase</a> to report any parse errors to the given <a href='#MultiFileErrorCollector'>MultiFileErrorCollector</a>.  <a href="#SourceTreeDescriptorDatabase.RecordErrorsTo.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code><a href='google.protobuf.descriptor#DescriptorPool.ErrorCollector'>DescriptorPool::ErrorCollector</a> *</code></td><td style="border-left-width: 0px"id="SourceTreeDescriptorDatabase.GetValidationErrorCollector"><div style="padding-left: 16px; text-indent: -16px"><code><b>GetValidationErrorCollector</b>()</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Gets a <a href='google.protobuf.descriptor#DescriptorPool.ErrorCollector'>DescriptorPool::ErrorCollector</a> which records errors to the <a href='#MultiFileErrorCollector'>MultiFileErrorCollector</a> specified with <a href='#SourceTreeDescriptorDatabase.RecordErrorsTo'>RecordErrorsTo()</a>.  <a href="#SourceTreeDescriptorDatabase.GetValidationErrorCollector.details">more...</a></div></td></tr><tr><th colspan="2"><h3 style="margin-top: 4px; margin-bottom: 4px;">implements <a href='google.protobuf.descriptor_database#DescriptorDatabase'>DescriptorDatabase</a></h3><div style="font-style: italic; font-weight: normal;"></div></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual bool</code></td><td style="border-left-width: 0px"id="SourceTreeDescriptorDatabase.FindFileByName"><div style="padding-left: 16px; text-indent: -16px"><code><b>FindFileByName</b>(const std::string &amp; filename, FileDescriptorProto * output)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Find a file by file name.  <a href="#SourceTreeDescriptorDatabase.FindFileByName.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual bool</code></td><td style="border-left-width: 0px"id="SourceTreeDescriptorDatabase.FindFileContainingSymbol"><div style="padding-left: 16px; text-indent: -16px"><code><b>FindFileContainingSymbol</b>(const std::string &amp; symbol_name, FileDescriptorProto * output)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Find the file that declares the given fully-qualified symbol name.  <a href="#SourceTreeDescriptorDatabase.FindFileContainingSymbol.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual bool</code></td><td style="border-left-width: 0px"id="SourceTreeDescriptorDatabase.FindFileContainingExtension"><div style="padding-left: 16px; text-indent: -16px"><code><b>FindFileContainingExtension</b>(const std::string &amp; containing_type, int field_number, FileDescriptorProto * output)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Find the file which defines an extension extending the given message type with the given field number.  <a href="#SourceTreeDescriptorDatabase.FindFileContainingExtension.details">more...</a></div></td></tr></table> <hr><h3 id="SourceTreeDescriptorDatabase.RecordErrorsTo.details"><code>void SourceTreeDescriptorDatabase::RecordErrorsTo(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#MultiFileErrorCollector'>MultiFileErrorCollector</a> * error_collector)</code></h3><div style="margin-left: 16px"><p>Instructs the <a href='#SourceTreeDescriptorDatabase'>SourceTreeDescriptorDatabase</a> to report any parse errors to the given <a href='#MultiFileErrorCollector'>MultiFileErrorCollector</a>. </p><p>This should be called before parsing. error_collector must remain valid until either this method is called again or the <a href='#SourceTreeDescriptorDatabase'>SourceTreeDescriptorDatabase</a> is destroyed. </p>
</div> <hr><h3 id="SourceTreeDescriptorDatabase.GetValidationErrorCollector.details"><code><a href='google.protobuf.descriptor#DescriptorPool.ErrorCollector'>DescriptorPool::ErrorCollector</a> * <br>&nbsp;&nbsp;&nbsp;&nbsp;SourceTreeDescriptorDatabase::GetValidationErrorCollector()</code></h3><div style="margin-left: 16px"><p>Gets a <a href='google.protobuf.descriptor#DescriptorPool.ErrorCollector'>DescriptorPool::ErrorCollector</a> which records errors to the <a href='#MultiFileErrorCollector'>MultiFileErrorCollector</a> specified with <a href='#SourceTreeDescriptorDatabase.RecordErrorsTo'>RecordErrorsTo()</a>. </p><p>This collector has the ability to determine exact line and column numbers of errors from the information given to it by the <a href='google.protobuf.descriptor#DescriptorPool'>DescriptorPool</a>. </p>
</div> <hr><h3 id="SourceTreeDescriptorDatabase.FindFileByName.details"><code>virtual bool SourceTreeDescriptorDatabase::FindFileByName(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string &amp; filename,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileDescriptorProto * output)</code></h3><div style="margin-left: 16px"><p>Find a file by file name. </p><p>Fills in in *output and returns true if found. Otherwise, returns false, leaving the contents of *output undefined. </p>
</div> <hr><h3 id="SourceTreeDescriptorDatabase.FindFileContainingSymbol.details"><code>virtual bool SourceTreeDescriptorDatabase::FindFileContainingSymbol(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string &amp; symbol_name,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileDescriptorProto * output)</code></h3><div style="margin-left: 16px"><p>Find the file that declares the given fully-qualified symbol name. </p><p>If found, fills in *output and returns true, otherwise returns false and leaves *output undefined. </p>
</div> <hr><h3 id="SourceTreeDescriptorDatabase.FindFileContainingExtension.details"><code>virtual bool SourceTreeDescriptorDatabase::FindFileContainingExtension(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string &amp; containing_type,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int field_number,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileDescriptorProto * output)</code></h3><div style="margin-left: 16px"><p>Find the file which defines an extension extending the given message type with the given field number. </p><p>If found, fills in *output and returns true, otherwise returns false and leaves *output undefined. containing_type must be a fully-qualified type name. </p>
</div><h2 id="Importer">class Importer</h2><p><code>#include &lt;<a href="#">google/protobuf/compiler/importer.h</a>&gt;<br>namespace <a href="#google.protobuf.compiler">google::protobuf::compiler</a></code></p><p>Simple interface for parsing .proto files. </p><p>This wraps the process of opening the file, parsing it with a <a href='google.protobuf.compiler.parser#Parser'>Parser</a>, recursively parsing all its imports, and then cross-linking the results to produce a <a href='google.protobuf.descriptor#FileDescriptor'>FileDescriptor</a>.</p>
<p>This is really just a thin wrapper around <a href='#SourceTreeDescriptorDatabase'>SourceTreeDescriptorDatabase</a>. You may find that <a href='#SourceTreeDescriptorDatabase'>SourceTreeDescriptorDatabase</a> is more flexible.</p>
<table><tr><th colspan="2"><h3 style="margin-top: 4px">Members</h3></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="Importer.Importer"><div style="padding-left: 16px; text-indent: -16px"><code><b>Importer</b>(<a href='#SourceTree'>SourceTree</a> * source_tree, <a href='#MultiFileErrorCollector'>MultiFileErrorCollector</a> * error_collector)</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="Importer.~Importer"><div style="padding-left: 16px; text-indent: -16px"><code><b>~Importer</b>()</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>const <a href='google.protobuf.descriptor#FileDescriptor'>FileDescriptor</a> *</code></td><td style="border-left-width: 0px"id="Importer.Import"><div style="padding-left: 16px; text-indent: -16px"><code><b>Import</b>(const std::string &amp; filename)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Import the given file and build a <a href='google.protobuf.descriptor#FileDescriptor'>FileDescriptor</a> representing it.  <a href="#Importer.Import.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>const <a href='google.protobuf.descriptor#DescriptorPool'>DescriptorPool</a> *</code></td><td style="border-left-width: 0px"id="Importer.pool"><div style="padding-left: 16px; text-indent: -16px"><code><b>pool</b>() const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">The <a href='google.protobuf.descriptor#DescriptorPool'>DescriptorPool</a> in which all imported FileDescriptors and their contents are stored. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="Importer.AddUnusedImportTrackFile"><div style="padding-left: 16px; text-indent: -16px"><code><b>AddUnusedImportTrackFile</b>(const std::string &amp; file_name, bool is_error = false)</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="Importer.ClearUnusedImportTrackFiles"><div style="padding-left: 16px; text-indent: -16px"><code><b>ClearUnusedImportTrackFiles</b>()</code></div></td></tr></table> <hr><h3 id="Importer.Import.details"><code>const <a href='google.protobuf.descriptor#FileDescriptor'>FileDescriptor</a> * <br>&nbsp;&nbsp;&nbsp;&nbsp;Importer::Import(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string &amp; filename)</code></h3><div style="margin-left: 16px"><p>Import the given file and build a <a href='google.protobuf.descriptor#FileDescriptor'>FileDescriptor</a> representing it. </p><p>If the file is already in the <a href='google.protobuf.descriptor#DescriptorPool'>DescriptorPool</a>, the existing <a href='google.protobuf.descriptor#FileDescriptor'>FileDescriptor</a> will be returned. The <a href='google.protobuf.descriptor#FileDescriptor'>FileDescriptor</a> is property of the <a href='google.protobuf.descriptor#DescriptorPool'>DescriptorPool</a>, and will remain valid until it is destroyed. If any errors occur, they will be reported using the error collector and <a href='#Importer.Import'>Import()</a> will return NULL.</p>
<p>A particular <a href='#Importer'>Importer</a> object will only report errors for a particular file once. All future attempts to import the same file will return NULL without reporting any errors. The idea is that you might want to import a lot of files without seeing the same errors over and over again. If you want to see errors for the same files repeatedly, you can use a separate <a href='#Importer'>Importer</a> object to import each one (but use the same <a href='google.protobuf.descriptor#DescriptorPool'>DescriptorPool</a> so that they can be cross-linked). </p>
</div><h2 id="MultiFileErrorCollector">class MultiFileErrorCollector</h2><p><code>#include &lt;<a href="#">google/protobuf/compiler/importer.h</a>&gt;<br>namespace <a href="#google.protobuf.compiler">google::protobuf::compiler</a></code></p><p>If the importer encounters problems while trying to import the proto files, it reports them to a <a href='#MultiFileErrorCollector'>MultiFileErrorCollector</a>. </p><table><tr><th colspan="2"><h3 style="margin-top: 4px">Members</h3></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="MultiFileErrorCollector.MultiFileErrorCollector"><div style="padding-left: 16px; text-indent: -16px"><code><b>MultiFileErrorCollector</b>()</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual </code></td><td style="border-left-width: 0px"id="MultiFileErrorCollector.~MultiFileErrorCollector"><div style="padding-left: 16px; text-indent: -16px"><code><b>~MultiFileErrorCollector</b>()</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual void</code></td><td style="border-left-width: 0px"id="MultiFileErrorCollector.AddError"><div style="padding-left: 16px; text-indent: -16px"><code><b>AddError</b>(const std::string &amp; filename, int line, int column, const std::string &amp; message)  = 0</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Line and column numbers are zero-based.  <a href="#MultiFileErrorCollector.AddError.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual void</code></td><td style="border-left-width: 0px"id="MultiFileErrorCollector.AddWarning"><div style="padding-left: 16px; text-indent: -16px"><code><b>AddWarning</b>(const std::string &amp; , int , int , const std::string &amp; )</code></div></td></tr></table> <hr><h3 id="MultiFileErrorCollector.AddError.details"><code>virtual void MultiFileErrorCollector::AddError(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string &amp; filename,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int line,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int column,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string &amp; message)  = 0</code></h3><div style="margin-left: 16px"><p>Line and column numbers are zero-based. </p><p>A line number of -1 indicates an error with the entire file (e.g. "not found"). </p>
</div><h2 id="SourceTree">class SourceTree</h2><p><code>#include &lt;<a href="#">google/protobuf/compiler/importer.h</a>&gt;<br>namespace <a href="#google.protobuf.compiler">google::protobuf::compiler</a></code></p><p>Abstract interface which represents a directory tree containing proto files. </p><p>Used by the default implementation of <a href='#Importer'>Importer</a> to resolve import statements Most users will probably want to use the <a href='#DiskSourceTree'>DiskSourceTree</a> implementation, below. </p>
<p>Known subclasses:</p><ul><li><code><a href="#DiskSourceTree">DiskSourceTree</a></code></li></ul><table><tr><th colspan="2"><h3 style="margin-top: 4px">Members</h3></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="SourceTree.SourceTree"><div style="padding-left: 16px; text-indent: -16px"><code><b>SourceTree</b>()</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual </code></td><td style="border-left-width: 0px"id="SourceTree.~SourceTree"><div style="padding-left: 16px; text-indent: -16px"><code><b>~SourceTree</b>()</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual <a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>io::ZeroCopyInputStream</a> *</code></td><td style="border-left-width: 0px"id="SourceTree.Open"><div style="padding-left: 16px; text-indent: -16px"><code><b>Open</b>(const std::string &amp; filename)  = 0</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Open the given file and return a stream that reads it, or NULL if not found.  <a href="#SourceTree.Open.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual std::string</code></td><td style="border-left-width: 0px"id="SourceTree.GetLastErrorMessage"><div style="padding-left: 16px; text-indent: -16px"><code><b>GetLastErrorMessage</b>()</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">If <a href='#SourceTree.Open'>Open()</a> returns NULL, calling this method immediately will return an description of the error.  <a href="#SourceTree.GetLastErrorMessage.details">more...</a></div></td></tr></table> <hr><h3 id="SourceTree.Open.details"><code>virtual <a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>io::ZeroCopyInputStream</a> * <br>&nbsp;&nbsp;&nbsp;&nbsp;SourceTree::Open(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string &amp; filename)  = 0</code></h3><div style="margin-left: 16px"><p>Open the given file and return a stream that reads it, or NULL if not found. </p><p>The caller takes ownership of the returned object. The filename must be a path relative to the root of the source tree and must not contain "." or ".." components. </p>
</div> <hr><h3 id="SourceTree.GetLastErrorMessage.details"><code>virtual std::string SourceTree::GetLastErrorMessage()</code></h3><div style="margin-left: 16px"><p>If <a href='#SourceTree.Open'>Open()</a> returns NULL, calling this method immediately will return an description of the error. </p><p>Subclasses should implement this method and return a meaningful value for better error reporting.</p>
</div><h2 id="DiskSourceTree">class DiskSourceTree: public <a href="#SourceTree">SourceTree</a></h2><p><code>#include &lt;<a href="#">google/protobuf/compiler/importer.h</a>&gt;<br>namespace <a href="#google.protobuf.compiler">google::protobuf::compiler</a></code></p><p>An implementation of <a href='#SourceTree'>SourceTree</a> which loads files from locations on disk. </p><p>Multiple mappings can be set up to map locations in the <a href='#DiskSourceTree'>DiskSourceTree</a> to locations in the physical filesystem. </p>
<table><tr><th colspan="2"><h3 style="margin-top: 4px">Members</h3></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>enum</code></td><td style="border-left-width: 0px"id="DiskSourceTree.DiskFileToVirtualFileResult"><div style="padding-left: 16px; text-indent: -16px"><code><b>DiskFileToVirtualFileResult</b></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Return type for <a href='#DiskSourceTree.DiskFileToVirtualFile'>DiskFileToVirtualFile()</a>.  <a href="#DiskSourceTree.DiskFileToVirtualFileResult.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="DiskSourceTree.DiskSourceTree"><div style="padding-left: 16px; text-indent: -16px"><code><b>DiskSourceTree</b>()</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="DiskSourceTree.~DiskSourceTree"><div style="padding-left: 16px; text-indent: -16px"><code><b>~DiskSourceTree</b>()</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="DiskSourceTree.MapPath"><div style="padding-left: 16px; text-indent: -16px"><code><b>MapPath</b>(const std::string &amp; virtual_path, const std::string &amp; disk_path)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;"><a href='google.protobuf.map#Map'>Map</a> a path on disk to a location in the <a href='#SourceTree'>SourceTree</a>.  <a href="#DiskSourceTree.MapPath.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code><a href='#DiskSourceTree.DiskFileToVirtualFileResult'>DiskFileToVirtualFileResult</a></code></td><td style="border-left-width: 0px"id="DiskSourceTree.DiskFileToVirtualFile"><div style="padding-left: 16px; text-indent: -16px"><code><b>DiskFileToVirtualFile</b>(const std::string &amp; disk_file, std::string * virtual_file, std::string * shadowing_disk_file)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Given a path to a file on disk, find a virtual path mapping to that file.  <a href="#DiskSourceTree.DiskFileToVirtualFile.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="DiskSourceTree.VirtualFileToDiskFile"><div style="padding-left: 16px; text-indent: -16px"><code><b>VirtualFileToDiskFile</b>(const std::string &amp; virtual_file, std::string * disk_file)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Given a virtual path, find the path to the file on disk.  <a href="#DiskSourceTree.VirtualFileToDiskFile.details">more...</a></div></td></tr><tr><th colspan="2"><h3 style="margin-top: 4px; margin-bottom: 4px;">implements <a href='#SourceTree'>SourceTree</a></h3><div style="font-style: italic; font-weight: normal;"></div></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual <a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>io::ZeroCopyInputStream</a> *</code></td><td style="border-left-width: 0px"id="DiskSourceTree.Open"><div style="padding-left: 16px; text-indent: -16px"><code><b>Open</b>(const std::string &amp; filename)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Open the given file and return a stream that reads it, or NULL if not found.  <a href="#DiskSourceTree.Open.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual std::string</code></td><td style="border-left-width: 0px"id="DiskSourceTree.GetLastErrorMessage"><div style="padding-left: 16px; text-indent: -16px"><code><b>GetLastErrorMessage</b>()</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">If <a href='#DiskSourceTree.Open'>Open()</a> returns NULL, calling this method immediately will return an description of the error.  <a href="#DiskSourceTree.GetLastErrorMessage.details">more...</a></div></td></tr></table> <hr><h3 id="DiskSourceTree.DiskFileToVirtualFileResult.details"><code>enum DiskSourceTree::DiskFileToVirtualFileResult {<br>&nbsp;&nbsp;SUCCESS,<br>&nbsp;&nbsp;SHADOWED,<br>&nbsp;&nbsp;CANNOT_OPEN,<br>&nbsp;&nbsp;NO_MAPPING<br>}</code></h3><div style="margin-left: 16px"><p>Return type for <a href='#DiskSourceTree.DiskFileToVirtualFile'>DiskFileToVirtualFile()</a>. </p><table><tr><td>SUCCESS</td><td></td></tr><tr><td>SHADOWED</td><td></td></tr><tr><td>CANNOT_OPEN</td><td></td></tr><tr><td>NO_MAPPING</td><td></td></tr></table></div> <hr><h3 id="DiskSourceTree.MapPath.details"><code>void DiskSourceTree::MapPath(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string &amp; virtual_path,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string &amp; disk_path)</code></h3><div style="margin-left: 16px"><p><a href='google.protobuf.map#Map'>Map</a> a path on disk to a location in the <a href='#SourceTree'>SourceTree</a>. </p><p>The path may be either a file or a directory. If it is a directory, the entire tree under it will be mapped to the given virtual location. To map a directory to the root of the source tree, pass an empty string for virtual_path.</p>
<p>If multiple mapped paths apply when opening a file, they will be searched in order. For example, if you do: </p>
<pre>MapPath("bar", "foo/bar");
MapPath("", "baz");</pre>
<p> and then you do: </p>
<pre>Open("bar/qux");</pre>
<p> the <a href='#DiskSourceTree'>DiskSourceTree</a> will first try to open foo/bar/qux, then baz/bar/qux, returning the first one that opens successfully.</p>
<p>disk_path may be an absolute path or relative to the current directory, just like a path you'd pass to open(). </p>
</div> <hr><h3 id="DiskSourceTree.DiskFileToVirtualFile.details"><code><a href='#DiskSourceTree.DiskFileToVirtualFileResult'>DiskFileToVirtualFileResult</a> <br>&nbsp;&nbsp;&nbsp;&nbsp;DiskSourceTree::DiskFileToVirtualFile(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string &amp; disk_file,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::string * virtual_file,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::string * shadowing_disk_file)</code></h3><div style="margin-left: 16px"><p>Given a path to a file on disk, find a virtual path mapping to that file. </p><p>The first mapping created with <a href='#DiskSourceTree.MapPath'>MapPath()</a> whose disk_path contains the filename is used. However, that virtual path may not actually be usable to open the given file. Possible return values are:</p>
<ul>
  <li>SUCCESS: The mapping was found. *virtual_file is filled in so that calling Open(*virtual_file) will open the file named by disk_file.</li>
  <li>SHADOWED: A mapping was found, but using <a href='#DiskSourceTree.Open'>Open()</a> to open this virtual path will end up returning some different file. This is because some other mapping with a higher precedence also matches this virtual path and maps it to a different file that exists on disk. *virtual_file is filled in as it would be in the SUCCESS case. *shadowing_disk_file is filled in with the disk path of the file which would be opened if you were to call Open(*virtual_file).</li>
  <li>CANNOT_OPEN: The mapping was found and was not shadowed, but the file specified cannot be opened. When this value is returned, errno will indicate the reason the file cannot be opened. *virtual_file will be set to the virtual path as in the SUCCESS case, even though it is not useful.</li>
  <li>NO_MAPPING: Indicates that no mapping was found which contains this file. </li>
</ul>
</div> <hr><h3 id="DiskSourceTree.VirtualFileToDiskFile.details"><code>bool DiskSourceTree::VirtualFileToDiskFile(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string &amp; virtual_file,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::string * disk_file)</code></h3><div style="margin-left: 16px"><p>Given a virtual path, find the path to the file on disk. </p><p>Return true and update disk_file with the on-disk path if the file exists. Return false and leave disk_file untouched if the file doesn't exist. </p>
</div> <hr><h3 id="DiskSourceTree.Open.details"><code>virtual <a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>io::ZeroCopyInputStream</a> * <br>&nbsp;&nbsp;&nbsp;&nbsp;DiskSourceTree::Open(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string &amp; filename)</code></h3><div style="margin-left: 16px"><p>Open the given file and return a stream that reads it, or NULL if not found. </p><p>The caller takes ownership of the returned object. The filename must be a path relative to the root of the source tree and must not contain "." or ".." components. </p>
</div> <hr><h3 id="DiskSourceTree.GetLastErrorMessage.details"><code>virtual std::string DiskSourceTree::GetLastErrorMessage()</code></h3><div style="margin-left: 16px"><p>If <a href='#DiskSourceTree.Open'>Open()</a> returns NULL, calling this method immediately will return an description of the error. </p><p>Subclasses should implement this method and return a meaningful value for better error reporting.</p>
</div>
