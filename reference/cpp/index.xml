<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C++ Reference on Protocol Buffers Documentation</title><link>https://protobuf.dev/reference/cpp/</link><description>Recent content in C++ Reference on Protocol Buffers Documentation</description><generator>Hugo</generator><language>en</language><atom:link href="https://protobuf.dev/reference/cpp/index.xml" rel="self" type="application/rss+xml"/><item><title>C++ Generated Code Guide</title><link>https://protobuf.dev/reference/cpp/cpp-generated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/cpp-generated/</guid><description>Any differences between proto2 and proto3 generated code are highlighted - note that these differences are in the generated code as described in this document, not the base message classes/interfaces, which are the same in both versions. You should read the proto2 language guide and/or proto3 language guide before reading this document.
Compiler Invocation The protocol buffer compiler produces C++ output when invoked with the --cpp_out= command-line flag. The parameter to the --cpp_out= option is the directory where you want the compiler to write your C++ output.</description></item><item><title>String View APIs</title><link>https://protobuf.dev/reference/cpp/string-view/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/string-view/</guid><description>C++ string field APIs that use std::string significantly constrain the internal protobuf implementation and its evolution. For example, mutable_string_field() returns std::string* that forces us to use std::string to store the field. This complicates its interaction on arenas and we have to maintain arena donation states to track whether string payload allocation is from arena or heap.
Long-term, we would like to migrate all of our runtime and generated APIs to accept string_view as inputs and return them from accessors.</description></item><item><title>C++ Arena Allocation Guide</title><link>https://protobuf.dev/reference/cpp/arenas/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/arenas/</guid><description>This page describes exactly what C++ code the protocol buffer compiler generates in addition to the code described in the C++ Generated Code Guide when arena allocation is enabled. It assumes that you are familiar with the material in the language guide and the C++ Generated Code Guide.
Why Use Arena Allocation? Memory allocation and deallocation constitutes a significant fraction of CPU time spent in protocol buffers code. By default, protocol buffers performs heap allocations for each message object, each of its subobjects, and several field types, such as strings.</description></item><item><title>Abseil Support</title><link>https://protobuf.dev/reference/cpp/abseil/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/abseil/</guid><description>In version 22.x, C++ protobuf added an explicit dependency on Abseil.
Bazel Support If you are using Bazel, to determine the version of Abseil that your protobuf version supports, you can use the bazel mod command:
$ bazel mod deps abseil-cpp --enable_bzlmod &amp;lt;root&amp;gt; (protobuf@30.0-dev) └───abseil-cpp@20240722.0 ├───bazel_skylib@1.7.1 ├───googletest@1.15.2 └───platforms@0.0.10 bazel mod graph produces the full output:
$ bazel mod graph --enable_bzlmod &amp;lt;root&amp;gt; (protobuf@30.0-dev) ├───abseil-cpp@20240722.0 │ ├───bazel_skylib@1.7.1 (*) │ ├───googletest@1.15.2 (*) │ └───platforms@0.</description></item><item><title>C++ API</title><link>https://protobuf.dev/reference/cpp/api-docs-link/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs-link/</guid><description/></item></channel></rss>