<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Rust Reference on Protocol Buffers Documentation</title><link>https://protobuf.dev/reference/rust/</link><description>Recent content in Rust Reference on Protocol Buffers Documentation</description><generator>Hugo</generator><language>en</language><atom:link href="https://protobuf.dev/reference/rust/index.xml" rel="self" type="application/rss+xml"/><item><title>Rust Generated Code Guide</title><link>https://protobuf.dev/reference/rust/rust-generated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/rust/rust-generated/</guid><description>This page describes exactly what Rust code the protocol buffer compiler generates for any given protocol definition.
This document covers how the protocol buffer compiler generates Rust code for proto2, proto3, and protobuf editions. Any differences between proto2, proto3, and editions generated code are highlighted. You should read the proto2 language guide, proto3 language guide, or editions guide before reading this document.
Protobuf Rust Protobuf Rust is an implementation of protocol buffers designed to be able to sit on top of other existing protocol buffer implementations that we refer to as &amp;lsquo;kernels&amp;rsquo;.</description></item><item><title>Redaction in Rust</title><link>https://protobuf.dev/reference/rust/rust-redaction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/rust/rust-redaction/</guid><description>Use the standard fmt::Debug (&amp;quot;{:?}&amp;quot; in format strings) on Protobuf messages for human-readable strings for logging, error messages, exceptions, and similar use cases. The output of this debug info is not intended to be machine-readable (unlike TextFormat and JSON which are not be used for debug output).
Using fmt::Debug enables redaction of some sensitive fields.
Note that under upb kernel this redaction is not yet implemented, but is expected to be added.</description></item><item><title>Building Rust Protos</title><link>https://protobuf.dev/reference/rust/building-rust-protos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/rust/building-rust-protos/</guid><description>Cargo See the protobuf-example crate for an example of how to set up your build.
Bazel The process of building a Rust library for a Protobuf definition is similar to other programming languages:
Use the language-agnostic proto_library rule:
proto_library( name = &amp;#34;person_proto&amp;#34;, srcs = [&amp;#34;person.proto&amp;#34;], ) Create a Rust library:
load(&amp;#34;//third_party/protobuf/rust:defs.bzl&amp;#34;, &amp;#34;rust_proto_library&amp;#34;) proto_library( name = &amp;#34;person_proto&amp;#34;, srcs = [&amp;#34;person.proto&amp;#34;], ) rust_proto_library( name = &amp;#34;person_rust_proto&amp;#34;, deps = [&amp;#34;:person_proto&amp;#34;], ) Use the library by including it in a Rust binary:</description></item><item><title>Rust Proto Design Decisions</title><link>https://protobuf.dev/reference/rust/rust-design-decisions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/rust/rust-design-decisions/</guid><description>As with any library, Rust Protobuf is designed considering the needs of both Google&amp;rsquo;s first-party usage of Rust as well that of external users. Choosing a path in that design space means that some choices made will not be optimal for some users in some cases, even if it is the right choice for the implementation overall.
This page covers some of the larger design decisions that the Rust Protobuf implementation makes and the considerations which led to those decisions.</description></item></channel></rss>