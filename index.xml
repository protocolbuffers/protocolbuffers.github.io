<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Protocol Buffers on Protocol Buffers Documentation</title><link>https://protobuf.dev/</link><description>Recent content in Protocol Buffers on Protocol Buffers Documentation</description><generator>Hugo</generator><language>en</language><atom:link href="https://protobuf.dev/index.xml" rel="self" type="application/rss+xml"/><item><title>Overview</title><link>https://protobuf.dev/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/overview/</guid><description>It’s like JSON, except it&amp;rsquo;s smaller and faster, and it generates native language bindings. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages.
Protocol buffers are a combination of the definition language (created in .proto files), the code that the proto compiler generates to interface with data, language-specific runtime libraries, the serialization format for data that is written to a file (or sent across a network connection), and the serialized data.</description></item><item><title>Protocol Buffer Compiler Installation</title><link>https://protobuf.dev/installation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/installation/</guid><description>The protocol buffer compiler, protoc, is used to compile .proto files, which contain service and message definitions. Choose one of the methods given below to install protoc.
Install Pre-compiled Binaries (Any OS) To install the latest release of the protocol compiler from pre-compiled binaries, follow these instructions:
From https://github.com/google/protobuf/releases, manually download the zip file corresponding to your operating system and computer architecture (protoc-&amp;lt;version&amp;gt;-&amp;lt;os&amp;gt;-&amp;lt;arch&amp;gt;.zip), or fetch the file using commands such as the following:</description></item><item><title>Language Guide (editions)</title><link>https://protobuf.dev/programming-guides/editions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/editions/</guid><description>This guide describes how to use the protocol buffer language to structure your protocol buffer data, including .proto file syntax and how to generate data access classes from your .proto files. It covers edition 2023 of the protocol buffers language. For information about how editions differ from proto2 and proto3 conceptually, see Protobuf Editions Overview.
For information on the proto2 syntax, see the Proto2 Language Guide.
For information on proto3 syntax, see the Proto3 Language Guide.</description></item><item><title>Language Guide (proto 2)</title><link>https://protobuf.dev/programming-guides/proto2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/proto2/</guid><description>This guide describes how to use the protocol buffer language to structure your protocol buffer data, including .proto file syntax and how to generate data access classes from your .proto files. It covers the proto2 revision of the protocol buffers language.
For information on editions syntax, see the Protobuf Editions Language Guide.
For information on proto3 syntax, see the Proto3 Language Guide.
This is a reference guide – for a step by step example that uses many of the features described in this document, see the tutorial for your chosen language.</description></item><item><title>Language Guide (proto 3)</title><link>https://protobuf.dev/programming-guides/proto3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/proto3/</guid><description>This guide describes how to use the protocol buffer language to structure your protocol buffer data, including .proto file syntax and how to generate data access classes from your .proto files. It covers the proto3 revision of the protocol buffers language.
For information on editions syntax, see the Protobuf Editions Language Guide.
For information on the proto2 syntax, see the Proto2 Language Guide.
This is a reference guide – for a step by step example that uses many of the features described in this document, see the tutorial for your chosen language.</description></item><item><title>Protobuf Editions Overview</title><link>https://protobuf.dev/editions/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/editions/overview/</guid><description>Protobuf Editions replace the proto2 and proto3 designations that we have used for Protocol Buffers. Instead of adding syntax = &amp;quot;proto2&amp;quot; or syntax = &amp;quot;proto3&amp;quot; at the top of proto definition files, you use an edition number, such as edition = &amp;quot;2023&amp;quot;, to specify the default behaviors your file will have. Editions enable the language to evolve incrementally over time.
Instead of the hardcoded behaviors that older versions have had, editions represent a collection of features with a default value (behavior) per feature.</description></item><item><title>Feature Settings for Editions</title><link>https://protobuf.dev/editions/features/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/editions/features/</guid><description>This topic provides an overview of the features that are included in Edition 2023. Each subsequent edition&amp;rsquo;s features will be added to this topic. We announce new editions in the News section.
Before configuring feature settings in your new schema definition content, make sure you understand why you are using them. Avoid cargo-culting with features.
Prototiller Prototiller is a command-line tool that converts proto2 and proto3 definition files to Editions syntax.</description></item><item><title>Implementing Editions Support</title><link>https://protobuf.dev/editions/implementation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/editions/implementation/</guid><description>This topic explains how to implement editions in new runtimes and generators.
Overview Edition 2023 The first edition released is Edition 2023, which is designed to unify proto2 and proto3 syntax. The features we’ve added to cover the difference in behaviors are detailed in Feature Settings for Editions.
Feature Definition In addition to supporting editions and the global features we&amp;rsquo;ve defined, you may want to define your own features to leverage the infrastructure.</description></item><item><title>Proto Limits</title><link>https://protobuf.dev/programming-guides/proto-limits/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/proto-limits/</guid><description>This topic documents the limits to the number of supported elements (fields, enum values, and so on) in proto schemas.
This information is a collection of discovered limitations by many engineers, but is not exhaustive and may be incorrect/outdated in some areas. As you discover limitations in your work, contribute those to this document to help others.
Number of Fields Message with only singular proto fields (such as Boolean):
~2100 fields (proto2) ~3100 (proto3 without using optional fields) Empty message extended by singular fields (such as Boolean):</description></item><item><title>Style Guide</title><link>https://protobuf.dev/programming-guides/style/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/style/</guid><description>This document provides a style guide for .proto files. By following these conventions, you&amp;rsquo;ll make your protocol buffer message definitions and their corresponding classes consistent and easy to read.
Standard File Formatting Keep the line length to 80 characters. Use an indent of 2 spaces. Prefer the use of double quotes for strings. File Structure Files should be named lower_snake_case.proto.
All files should be ordered in the following manner:
License header (if applicable) File overview Syntax Package Imports (sorted) File options Everything else Identifier naming styles Protobuf identifiers use one of the following naming styles:</description></item><item><title>Enum Behavior</title><link>https://protobuf.dev/programming-guides/enum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/enum/</guid><description>Enums behave differently in different language libraries. This topic covers the different behaviors as well as the plans to move protobufs to a state where they are consistent across all languages. If you&amp;rsquo;re looking for information on how to use enums in general, see the corresponding sections in the proto2 and proto3 language guide topics.
Definitions Enums have two distinct flavors (open and closed). They behave identically except in their handling of unknown values.</description></item><item><title>Encoding</title><link>https://protobuf.dev/programming-guides/encoding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/encoding/</guid><description>This document describes the protocol buffer wire format, which defines the details of how your message is sent on the wire and how much space it consumes on disk. You probably don&amp;rsquo;t need to understand this to use protocol buffers in your application, but it&amp;rsquo;s useful information for doing optimizations.
If you already know the concepts but want a reference, skip to the Condensed reference card section.
Protoscope is a very simple language for describing snippets of the low-level wire format, which we&amp;rsquo;ll use to provide a visual reference for the encoding of various messages.</description></item><item><title>ProtoJSON Format</title><link>https://protobuf.dev/programming-guides/json/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/json/</guid><description>Protobuf supports a canonical encoding in JSON, making it easier to share data with systems that do not support the standard protobuf binary wire format.
ProtoJSON Format is not as efficient as protobuf wire format. The converter uses more CPU to encode and decode messages and (except in rare cases) encoded messages consume more space. Furthermore, ProtoJSON format puts your field and enum value names into encoded messages making it much harder to change those names later.</description></item><item><title>Techniques</title><link>https://protobuf.dev/programming-guides/techniques/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/techniques/</guid><description>You can also send design and usage questions to the Protocol Buffers discussion group.
Common Filename Suffixes It is fairly common to write messages to files in several different formats. We recommend using the following file extensions for these files.
Content Extension Text Format .txtpb Wire Format .binpb JSON Format .json For Text Format specifically, .textproto is also fairly common, but we recommend .txtpb for its brevity.
Streaming Multiple Messages If you want to write multiple messages to a single file or stream, it is up to you to keep track of where one message ends and the next begins.</description></item><item><title>Third-Party Add-ons</title><link>https://protobuf.dev/programming-guides/addons/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/addons/</guid><description>Many open source projects seek to add useful functionality on top of Protocol Buffers. For a list of links to projects we know about, see the third-party add-ons wiki page.</description></item><item><title>Extension Declarations</title><link>https://protobuf.dev/programming-guides/extension_declarations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/extension_declarations/</guid><description>Introduction This page describes in detail what extension declarations are, why we need them, and how we use them.
Note Proto3 does not support extensions (except for declaring custom options). Extensions are fully supported in proto2 and editions though. If you need an introduction to extensions, read this extensions guide
Motivation Extension declarations aim to strike a happy medium between regular fields and extensions. Like extensions, they avoid creating a dependency on the message type of the field, which therefore results in a leaner build graph and smaller binaries in environments where unused messages are difficult or impossible to strip.</description></item><item><title>Application Note: Field Presence</title><link>https://protobuf.dev/programming-guides/field_presence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/field_presence/</guid><description>Background Field presence is the notion of whether a protobuf field has a value. There are two different manifestations of presence for protobufs: implicit presence, where the generated message API stores field values (only), and explicit presence, where the API also stores whether or not a field has been set.
Note We recommend always adding the optional label for proto3 basic types. This provides a smoother path to editions, which uses explicit presence by default.</description></item><item><title>Proto Serialization Is Not Canonical</title><link>https://protobuf.dev/programming-guides/serialization-not-canonical/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/serialization-not-canonical/</guid><description>Many people want a serialized proto to canonically represent the contents of that proto. Use cases include:
using a serialized proto as a key in a hash table taking a fingerprint or checksum of a serialized proto comparing serialized payloads as a way of checking message equality Unfortunately, protobuf serialization is not (and cannot be) canonical. There are a few notable exceptions, such as MapReduce, but in general you should generally think of proto serialization as unstable.</description></item><item><title>Deserializing Debug Proto Representations</title><link>https://protobuf.dev/programming-guides/deserialize-debug/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/programming-guides/deserialize-debug/</guid><description>From version 30.x, Protobuf DebugString APIs (Message::DebugString, Message::ShortDebugString, Message::Utf8DebugString), additional Protobuf APIs (proto2::ShortFormat, proto2::Utf8Format), Abseil string functions (such as absl::StrCat, absl::StrFormat, absl::StrAppend, and absl::Substitute), and Abseil logging API will begin to automatically convert proto arguments into a new debugging format . See the related announcement here.
Unlike the Protobuf DebugString output format, the new debugging format automatically redacts sensitive fields by replacing their values with the string &amp;ldquo;[REDACTED]&amp;rdquo; (without the quotation marks).</description></item><item><title>No Nullable Setters/Getters Support</title><link>https://protobuf.dev/design-decisions/nullable-getters-setters/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/design-decisions/nullable-getters-setters/</guid><description>We have heard feedback that some folks would like protobuf to support nullable getters/setters in their null-friendly language of choice (particularly Kotlin, C#, and Rust). While this does seem to be a helpful feature for folks using those languages, the design choice has tradeoffs which have led to the Protobuf team choosing not to implement them.
The biggest reason not to have nullable fields is the intended behavior of default values specified in a .</description></item><item><title>Avoid Cargo Culting</title><link>https://protobuf.dev/best-practices/no-cargo-cults/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/best-practices/no-cargo-cults/</guid><description>Do not cargo cult settings in proto files. If you are creating a new proto file based on existing schema definitions, don&amp;rsquo;t apply option settings except for those that you understand the need for.
Best Practices Specific to Editions Avoid applying editions features except when they&amp;rsquo;re actually necessary. Features in .proto files signal the use of either experimental future behaviors or deprecated past behaviors. Best practices for the latest edition will always be the default.</description></item><item><title>Proto Best Practices</title><link>https://protobuf.dev/best-practices/dos-donts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/best-practices/dos-donts/</guid><description>Clients and servers are never updated at exactly the same time - even when you try to update them at the same time. One or the other may get rolled back. Don’t assume that you can make a breaking change and it&amp;rsquo;ll be okay because the client and server are in sync.
Don&amp;rsquo;t Re-use a Tag Number Never re-use a tag number. It messes up deserialization. Even if you think no one is using the field, don’t re-use a tag number.</description></item><item><title>API Best Practices</title><link>https://protobuf.dev/best-practices/api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/best-practices/api/</guid><description>Updated for proto3. Patches welcome!
This doc is a complement to Proto Best Practices. It&amp;rsquo;s not a prescription for Java/C++/Go and other APIs.
If you see a proto straying from these guidelines in a code review, point the author to this topic and help spread the word.
Note These guidelines are just that and many have documented exceptions. For example, if you&amp;rsquo;re writing a performance-critical backend, you might want to sacrifice flexibility or safety for speed.</description></item><item><title>1-1-1 Best Practice</title><link>https://protobuf.dev/best-practices/1-1-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/best-practices/1-1-1/</guid><description>The 1-1-1 best practice is to keep every proto_library and .proto file as small as is reasonable, with the ideal being:
One proto_library build rule One source .proto file One top-level entity (message, enum, or extension) Having the fewest number of message, enum, extension, and services as you reasonably can makes refactoring easier. Moving files when they&amp;rsquo;re separated is much easier than extracting messages from a file with other messages.</description></item><item><title>Protocol Buffer Basics: C++</title><link>https://protobuf.dev/getting-started/cpptutorial/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/getting-started/cpptutorial/</guid><description>This tutorial provides a basic C++ programmers introduction to working with protocol buffers. By walking through creating a simple example application, it shows you how to
Define message formats in a .proto file. Use the protocol buffer compiler. Use the C++ protocol buffer API to write and read messages. This isn&amp;rsquo;t a comprehensive guide to using protocol buffers in C++. For more detailed reference information, see the Protocol Buffer Language Guide (proto2), the Protocol Buffer Language Guide (proto3), the C++ API Reference, the C++ Generated Code Guide, and the Encoding Reference.</description></item><item><title>Protocol Buffer Basics: C#</title><link>https://protobuf.dev/getting-started/csharptutorial/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/getting-started/csharptutorial/</guid><description>This tutorial provides a basic C# programmer&amp;rsquo;s introduction to working with protocol buffers, using the proto3 version of the protocol buffers language. By walking through creating a simple example application, it shows you how to
Define message formats in a .proto file. Use the protocol buffer compiler. Use the C# protocol buffer API to write and read messages. This isn&amp;rsquo;t a comprehensive guide to using protocol buffers in C#. For more detailed reference information, see the Protocol Buffer Language Guide, the C# API Reference, the C# Generated Code Guide, and the Encoding Reference.</description></item><item><title>Protocol Buffer Basics: Dart</title><link>https://protobuf.dev/getting-started/darttutorial/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/getting-started/darttutorial/</guid><description>This tutorial provides a basic Dart programmer&amp;rsquo;s introduction to working with protocol buffers, using the proto3 version of the protocol buffers language. By walking through creating a simple example application, it shows you how to
Define message formats in a .proto file. Use the protocol buffer compiler. Use the Dart protocol buffer API to write and read messages. This isn&amp;rsquo;t a comprehensive guide to using protocol buffers in Dart . For more detailed reference information, see the Protocol Buffer Language Guide, the Dart Language Tour, the Dart API Reference, the Dart Generated Code Guide, and the Encoding Reference.</description></item><item><title>Protocol Buffer Basics: Go</title><link>https://protobuf.dev/getting-started/gotutorial/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/getting-started/gotutorial/</guid><description>This tutorial provides a basic Go programmer&amp;rsquo;s introduction to working with protocol buffers, using the proto3 version of the protocol buffers language. By walking through creating a simple example application, it shows you how to
Define message formats in a .proto file. Use the protocol buffer compiler. Use the Go protocol buffer API to write and read messages. This isn&amp;rsquo;t a comprehensive guide to using protocol buffers in Go. For more detailed reference information, see the Protocol Buffer Language Guide, the Go API Reference, the Go Generated Code Guide, and the Encoding Reference.</description></item><item><title>Protocol Buffer Basics: Java</title><link>https://protobuf.dev/getting-started/javatutorial/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/getting-started/javatutorial/</guid><description>This tutorial provides a basic Java programmer&amp;rsquo;s introduction to working with protocol buffers. By walking through creating a simple example application, it shows you how to
Define message formats in a .proto file. Use the protocol buffer compiler. Use the Java protocol buffer API to write and read messages. This isn&amp;rsquo;t a comprehensive guide to using protocol buffers in Java. For more detailed reference information, see the Protocol Buffer Language Guide (proto2), the Protocol Buffer Language Guide (proto3), the Java API Reference, the Java Generated Code Guide, and the Encoding Reference.</description></item><item><title>Protocol Buffer Basics: Kotlin</title><link>https://protobuf.dev/getting-started/kotlintutorial/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/getting-started/kotlintutorial/</guid><description>This tutorial provides a basic Kotlin programmer&amp;rsquo;s introduction to working with protocol buffers, using the proto3 version of the protocol buffers language. By walking through creating a simple example application, it shows you how to
Define message formats in a .proto file. Use the protocol buffer compiler. Use the Kotlin protocol buffer API to write and read messages. This isn&amp;rsquo;t a comprehensive guide to using protocol buffers in Kotlin. For more detailed reference information, see the Protocol Buffer Language Guide, the Kotlin API Reference, the Kotlin Generated Code Guide, and the Encoding Reference.</description></item><item><title>Protocol Buffer Basics: Python</title><link>https://protobuf.dev/getting-started/pythontutorial/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/getting-started/pythontutorial/</guid><description>This tutorial provides a basic Python programmer&amp;rsquo;s introduction to working with protocol buffers. By walking through creating a simple example application, it shows you how to
Define message formats in a .proto file. Use the protocol buffer compiler. Use the Python protocol buffer API to write and read messages. This isn&amp;rsquo;t a comprehensive guide to using protocol buffers in Python. For more detailed reference information, see the Protocol Buffer Language Guide (proto2), the Protocol Buffer Language Guide (proto3), the Python API Reference, the Python Generated Code Guide, and the Encoding Reference.</description></item><item><title>C++ Generated Code Guide</title><link>https://protobuf.dev/reference/cpp/cpp-generated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/cpp-generated/</guid><description>Any differences between proto2 and proto3 generated code are highlighted - note that these differences are in the generated code as described in this document, not the base message classes/interfaces, which are the same in both versions. You should read the proto2 language guide and/or proto3 language guide before reading this document.
Compiler Invocation The protocol buffer compiler produces C++ output when invoked with the --cpp_out= command-line flag. The parameter to the --cpp_out= option is the directory where you want the compiler to write your C++ output.</description></item><item><title>String View APIs</title><link>https://protobuf.dev/reference/cpp/string-view/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/string-view/</guid><description>C++ string field APIs that use std::string significantly constrain the internal protobuf implementation and its evolution. For example, mutable_string_field() returns std::string* that forces us to use std::string to store the field. This complicates its interaction on arenas and we have to maintain arena donation states to track whether string payload allocation is from arena or heap.
Long-term, we would like to migrate all of our runtime and generated APIs to accept string_view as inputs and return them from accessors.</description></item><item><title>C++ Arena Allocation Guide</title><link>https://protobuf.dev/reference/cpp/arenas/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/arenas/</guid><description>This page describes exactly what C++ code the protocol buffer compiler generates in addition to the code described in the C++ Generated Code Guide when arena allocation is enabled. It assumes that you are familiar with the material in the language guide and the C++ Generated Code Guide.
Why Use Arena Allocation? Memory allocation and deallocation constitutes a significant fraction of CPU time spent in protocol buffers code. By default, protocol buffers performs heap allocations for each message object, each of its subobjects, and several field types, such as strings.</description></item><item><title>Abseil Support</title><link>https://protobuf.dev/reference/cpp/abseil/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/abseil/</guid><description>In version 22.x, C++ protobuf added an explicit dependency on Abseil.
Bazel Support If you are using Bazel, to determine the version of Abseil that your protobuf version supports, you can use the bazel mod command:
$ bazel mod deps abseil-cpp --enable_bzlmod &amp;lt;root&amp;gt; (protobuf@30.0-dev) └───abseil-cpp@20240722.0 ├───bazel_skylib@1.7.1 ├───googletest@1.15.2 └───platforms@0.0.10 bazel mod graph produces the full output:
$ bazel mod graph --enable_bzlmod &amp;lt;root&amp;gt; (protobuf@30.0-dev) ├───abseil-cpp@20240722.0 │ ├───bazel_skylib@1.7.1 (*) │ ├───googletest@1.15.2 (*) │ └───platforms@0.</description></item><item><title>C++ API</title><link>https://protobuf.dev/reference/cpp/api-docs-link/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs-link/</guid><description/></item><item><title>C# Generated Code Guide</title><link>https://protobuf.dev/reference/csharp/csharp-generated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/csharp/csharp-generated/</guid><description>You should read the proto3 language guide before reading this document.
Note The protobuf compiler can generate C# interfaces for definitions using proto2 syntax starting from release 3.10. Refer to the proto2 language guide for details of the semantics of proto2 definitions, and see docs/csharp/proto2.md (view on GitHub) for details on the generated C# code for proto2. Compiler Invocation The protocol buffer compiler produces C# output when invoked with the --csharp_out command-line flag.</description></item><item><title>C# API</title><link>https://protobuf.dev/reference/csharp/api-docs-link/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/csharp/api-docs-link/</guid><description/></item><item><title>Dart Generated Code</title><link>https://protobuf.dev/reference/dart/dart-generated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/dart/dart-generated/</guid><description>Any differences between proto2 and proto3 generated code are highlighted - note that these differences are in the generated code as described in this document, not the base API, which are the same in both versions. You should read the proto2 language guide and/or the proto3 language guide before reading this document.
Compiler Invocation The protocol buffer compiler requires a plugin to generate Dart code. Installing it following the instructions provides a protoc-gen-dart binary which protoc uses when invoked with the --dart_out command-line flag.</description></item><item><title>Dart API</title><link>https://protobuf.dev/reference/dart/api-docs-link/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/dart/api-docs-link/</guid><description/></item><item><title>Go Generated Code Guide (Open)</title><link>https://protobuf.dev/reference/go/go-generated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/go/go-generated/</guid><description>Any differences between proto2 and proto3 generated code are highlighted - note that these differences are in the generated code as described in this document, not the base API, which are the same in both versions. You should read the proto2 language guide and/or the proto3 language guide before reading this document.
Note You are looking at documentation for the old generated code API (Open Struct API). See Go Generated Code (Opaque) for the corresponding documentation of the (new) Opaque API.</description></item><item><title>Go Generated Code Guide (Opaque)</title><link>https://protobuf.dev/reference/go/go-generated-opaque/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/go/go-generated-opaque/</guid><description>Any differences between proto2 and proto3 generated code are highlighted - note that these differences are in the generated code as described in this document, not the base API, which are the same in both versions. You should read the proto2 language guide and/or the proto3 language guide before reading this document.
Note You are looking at documentation for the Opaque API, which is the current version. If you are working with .</description></item><item><title>Go FAQ</title><link>https://protobuf.dev/reference/go/faq/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/go/faq/</guid><description>Versions What&amp;rsquo;s the difference between github.com/golang/protobuf and google.golang.org/protobuf? The github.com/golang/protobuf module is the original Go protocol buffer API.
The google.golang.org/protobuf module is an updated version of this API designed for simplicity, ease of use, and safety. The flagship features of the updated API are support for reflection and a separation of the user-facing API from the underlying implementation.
We recommend that you use google.golang.org/protobuf in new code.
Version v1.4.0 and higher of github.</description></item><item><title>Go Size Semantics</title><link>https://protobuf.dev/reference/go/size/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/go/size/</guid><description>The proto.Size function returns the size in bytes of the wire-format encoding of a proto.Message by traversing all its fields (including submessages).
In particular, it returns the size of how Go Protobuf will encode the message.
Typical usages Identifying empty messages Checking if proto.Size returns 0 is an easy way to recognize empty messages:
if proto.Size(m) == 0 { // No fields set (or, in proto3, all fields matching the default); // skip processing this message, or return an error, or similar.</description></item><item><title>Go API</title><link>https://protobuf.dev/reference/go/api-docs-link/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/go/api-docs-link/</guid><description/></item><item><title>Java Generated Code Guide</title><link>https://protobuf.dev/reference/java/java-generated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/java/java-generated/</guid><description>Any differences between proto2 and proto3 generated code are highlighted—note that these differences are in the generated code as described in this document, not the base message classes/interfaces, which are the same in both versions. You should read the proto2 language guide and/or proto3 language guide before reading this document.
Note that no Java protocol buffer methods accept or return nulls unless otherwise specified.
Compiler Invocation The protocol buffer compiler produces Java output when invoked with the --java_out= command-line flag.</description></item><item><title>Go Opaque API Migration</title><link>https://protobuf.dev/reference/go/opaque-migration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/go/opaque-migration/</guid><description>The Opaque API is the latest version of the Protocol Buffers implementation for the Go programming language. The old version is now called Open Struct API. See the Go Protobuf: Releasing the Opaque API blog post for an introduction.
The migration to the Opaque API happens incrementally, on a per-proto-message or per-.proto-file basis, by setting the Protobuf Editions feature api_level option to one of its possible values:
API_OPEN selects the Open Struct API; this was the only API before December 2024.</description></item><item><title>Java Proto Names</title><link>https://protobuf.dev/reference/java/java-proto-names/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/java/java-proto-names/</guid><description>This document contains information on what the fully-qualified Java name of a proto is, based on the different proto options. This name corresponds to the package you need to import to use that message.
Recommendation Set option java_multiple_files = true; Set option java_outer_classname = &amp;quot;FileNameProto&amp;quot;; Set option java_package = &amp;quot;com.google.package&amp;quot;; Explanation Multiple Files With java_multiple_files = true, the generated Java class for each message will be placed in a separate .</description></item><item><title>Java API</title><link>https://protobuf.dev/reference/java/api-docs-link/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/java/api-docs-link/</guid><description/></item><item><title>Go Opaque API: Manual Migration</title><link>https://protobuf.dev/reference/go/opaque-migration-manual/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/go/opaque-migration-manual/</guid><description>The Opaque API is the latest version of the Protocol Buffers implementation for the Go programming language. The old version is now called Open Struct API. See the Go Protobuf: Releasing the Opaque API blog post for an introduction.
This is a user guide for migrating Go Protobuf usages from the older Open Struct API to the new Opaque API.
Warning You are looking at the manual migration guide. Typically you’re better off using the open2opaque tool to automate the migration.</description></item><item><title>Go Opaque API FAQ</title><link>https://protobuf.dev/reference/go/opaque-faq/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/go/opaque-faq/</guid><description>The Opaque API is the latest version of the Protocol Buffers implementation for the Go programming language. The old version is now called Open Struct API. See the Go Protobuf: The new Opaque API blog post for an introduction.
This FAQ answers common questions about the new API and the migration process.
Which API Should I Use When Creating a New .proto File? We recommend you select the Opaque API for new development.</description></item><item><title>Kotlin Generated Code Guide</title><link>https://protobuf.dev/reference/kotlin/kotlin-generated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/kotlin/kotlin-generated/</guid><description>Any differences between proto2 and proto3 generated code are highlighted—note that these differences are in the generated code as described in this document, not the base message classes/interfaces, which are the same in both versions. You should read the proto2 language guide and/or proto3 language guide before reading this document.
Compiler Invocation The protocol buffer compiler produces Kotlin code that builds on top of Java code. As a result, it must be invoked with two command-line flags, --java_out= and --kotlin_out=.</description></item><item><title>Objective-C Generated Code Guide</title><link>https://protobuf.dev/reference/objective-c/objective-c-generated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/objective-c/objective-c-generated/</guid><description>Any differences between proto2 and proto3 generated code are highlighted. You should read the proto2 language guide and/or proto3 language guide before reading this document.
Compiler invocation The protocol buffer compiler produces Objective-C output when invoked with the --objc_out= command-line flag. The parameter to the --objc_out= option is the directory where you want the compiler to write your Objective-C output. The compiler creates a header file and an implementation file for each .</description></item><item><title>PHP Generated Code Guide</title><link>https://protobuf.dev/reference/php/php-generated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/php/php-generated/</guid><description>You should read the proto3 language guide before reading this document. Note that the protocol buffer compiler currently only supports proto3 code generation for PHP.
Compiler Invocation The protocol buffer compiler produces PHP output when invoked with the --php_out= command-line flag. The parameter to the --php_out= option is the directory where you want the compiler to write your PHP output. In order to conform to PSR-4, the compiler creates a sub-directory corresponding to the package defined in the proto file.</description></item><item><title>PHP API</title><link>https://protobuf.dev/reference/php/api-docs-link/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/php/api-docs-link/</guid><description/></item><item><title>Python Generated Code Guide</title><link>https://protobuf.dev/reference/python/python-generated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/python/python-generated/</guid><description>Any differences between proto2 and proto3 generated code are highlighted - note that these differences are in the generated code as described in this document, not the base message classes/interfaces, which are the same in both versions. You should read the proto2 language guide and/or proto3 language guide before reading this document.
The Python Protocol Buffers implementation is a little different from C++ and Java. In Python, the compiler only outputs code to build descriptors for the generated classes, and a Python metaclass does the real work.</description></item><item><title>Python API</title><link>https://protobuf.dev/reference/python/api-docs-link/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/python/api-docs-link/</guid><description/></item><item><title>Ruby Generated Code Guide</title><link>https://protobuf.dev/reference/ruby/ruby-generated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/ruby/ruby-generated/</guid><description>You should read the language guides for proto2 or proto3 before reading this document.
The protocol compiler for Ruby emits Ruby source files that use a DSL to define the message schema. However the DSL is still subject to change. In this guide we only describe the API of the generated messages, and not the DSL.
Compiler Invocation The protocol buffer compiler produces Ruby output when invoked with the --ruby_out= command-line flag.</description></item><item><title>Rust Generated Code Guide</title><link>https://protobuf.dev/reference/rust/rust-generated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/rust/rust-generated/</guid><description>This page describes exactly what Rust code the protocol buffer compiler generates for any given protocol definition.
Any differences between proto2 and proto3 generated code are highlighted. You should read the proto2 language guide and/or proto3 language guide before reading this document.
Protobuf Rust Protobuf Rust is an implementation of protocol buffers designed to be able to sit on top of other existing protocol buffer implementations that we refer to as &amp;lsquo;kernels&amp;rsquo;.</description></item><item><title>Redaction in Rust</title><link>https://protobuf.dev/reference/rust/rust-redaction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/rust/rust-redaction/</guid><description>Use the standard fmt::Debug (&amp;quot;{:?}&amp;quot; in format strings) on Protobuf messages for human-readable strings for logging, error messages, exceptions, and similar use cases. The output of this debug info is not intended to be machine-readable (unlike TextFormat and JSON which are not be used for debug output).
Using fmt::Debug enables redaction of some sensitive fields.
Note that under upb kernel this redaction is not yet implemented, but is expected to be added.</description></item><item><title>Building Rust Protos</title><link>https://protobuf.dev/reference/rust/building-rust-protos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/rust/building-rust-protos/</guid><description>The process of building a Rust library for a Protobuf definition is similar to other programming languages:
Use the language-agnostic proto_library rule:
proto_library( name = &amp;#34;person_proto&amp;#34;, srcs = [&amp;#34;person.proto&amp;#34;], ) Create a Rust library:
load(&amp;#34;//third_party/protobuf/rust:defs.bzl&amp;#34;, &amp;#34;rust_proto_library&amp;#34;) proto_library( name = &amp;#34;person_proto&amp;#34;, srcs = [&amp;#34;person.proto&amp;#34;], ) rust_proto_library( name = &amp;#34;person_rust_proto&amp;#34;, deps = [&amp;#34;:person_proto&amp;#34;], ) Use the library by including it in a Rust binary:
load(&amp;#34;//third_party/bazel_rules/rules_rust/rust:defs.bzl&amp;#34;, &amp;#34;rust_binary&amp;#34;) load(&amp;#34;//third_party/protobuf/rust:defs.bzl&amp;#34;, &amp;#34;rust_proto_library&amp;#34;) proto_library( name = &amp;#34;person_proto&amp;#34;, srcs = [&amp;#34;person.</description></item><item><title>Rust Proto Design Decisions</title><link>https://protobuf.dev/reference/rust/rust-design-decisions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/rust/rust-design-decisions/</guid><description>As with any library, Rust Protobuf is designed considering the needs of both Google&amp;rsquo;s first-party usage of Rust as well that of external users. Choosing a path in that design space means that some choices made will not be optimal for some users in some cases, even if it is the right choice for the implementation overall.
This page covers some of the larger design decisions that the Rust Protobuf implementation makes and the considerations which led to those decisions.</description></item><item><title>Protocol Buffers Edition 2023 Language Specification</title><link>https://protobuf.dev/reference/protobuf/edition-2023-spec/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/protobuf/edition-2023-spec/</guid><description>The syntax is specified using Extended Backus-Naur Form (EBNF):
| alternation () grouping [] option (zero or one time) {} repetition (any number of times) Lexical Elements Letters and Digits letter = &amp;#34;A&amp;#34; ... &amp;#34;Z&amp;#34; | &amp;#34;a&amp;#34; ... &amp;#34;z&amp;#34; capitalLetter = &amp;#34;A&amp;#34; ... &amp;#34;Z&amp;#34; decimalDigit = &amp;#34;0&amp;#34; ... &amp;#34;9&amp;#34; octalDigit = &amp;#34;0&amp;#34; ... &amp;#34;7&amp;#34; hexDigit = &amp;#34;0&amp;#34; ... &amp;#34;9&amp;#34; | &amp;#34;A&amp;#34; ... &amp;#34;F&amp;#34; | &amp;#34;a&amp;#34; ... &amp;#34;f&amp;#34; Identifiers ident = letter { letter | decimalDigit | &amp;#34;_&amp;#34; } fullIdent = ident { &amp;#34;.</description></item><item><title>Protocol Buffers Version 2 Language Specification</title><link>https://protobuf.dev/reference/protobuf/proto2-spec/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/protobuf/proto2-spec/</guid><description>The syntax is specified using Extended Backus-Naur Form (EBNF):
| alternation () grouping [] option (zero or one time) {} repetition (any number of times) For more information about using proto2, see the language guide.
Lexical Elements Letters and Digits letter = &amp;#34;A&amp;#34; ... &amp;#34;Z&amp;#34; | &amp;#34;a&amp;#34; ... &amp;#34;z&amp;#34; capitalLetter = &amp;#34;A&amp;#34; ... &amp;#34;Z&amp;#34; decimalDigit = &amp;#34;0&amp;#34; ... &amp;#34;9&amp;#34; octalDigit = &amp;#34;0&amp;#34; ... &amp;#34;7&amp;#34; hexDigit = &amp;#34;0&amp;#34; ... &amp;#34;9&amp;#34; | &amp;#34;A&amp;#34; .</description></item><item><title>Protocol Buffers Version 3 Language Specification</title><link>https://protobuf.dev/reference/protobuf/proto3-spec/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/protobuf/proto3-spec/</guid><description>The syntax is specified using Extended Backus-Naur Form (EBNF):
| alternation () grouping [] option (zero or one time) {} repetition (any number of times) For more information about using proto3, see the language guide.
Lexical Elements Letters and Digits letter = &amp;#34;A&amp;#34; ... &amp;#34;Z&amp;#34; | &amp;#34;a&amp;#34; ... &amp;#34;z&amp;#34; decimalDigit = &amp;#34;0&amp;#34; ... &amp;#34;9&amp;#34; octalDigit = &amp;#34;0&amp;#34; ... &amp;#34;7&amp;#34; hexDigit = &amp;#34;0&amp;#34; ... &amp;#34;9&amp;#34; | &amp;#34;A&amp;#34; ... &amp;#34;F&amp;#34; | &amp;#34;a&amp;#34; .</description></item><item><title>Text Format Language Specification</title><link>https://protobuf.dev/reference/protobuf/textformat-spec/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/protobuf/textformat-spec/</guid><description>This format is distinct from the format of text within a .proto schema, for example. This document contains reference documentation using the syntax specified in ISO/IEC 14977 EBNF.
Note This is a draft spec reverse-engineered from the C++ text format implementation and may change based on further discussion and review. While an effort has been made to keep text formats consistent across supported languages, incompatibilities are likely to exist. Example convolution_benchmark { label: &amp;#34;NHWC_128x20x20x56x160&amp;#34; input { dimension: [128, 56, 20, 20] data_type: DATA_HALF format: TENSOR_NHWC } } Parsing Overview The language elements in this spec are split into lexical and syntactic categories.</description></item><item><title>Protocol Buffers Well-Known Types</title><link>https://protobuf.dev/reference/protobuf/google.protobuf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/protobuf/google.protobuf/</guid><description>Index Any (message) Api (message) BoolValue (message) BytesValue (message) DoubleValue (message) Duration (message) Empty (message) Enum (message) EnumValue (message) Field (message) Field.Cardinality (enum) Field.Kind (enum) FieldMask (message) FloatValue (message) Int32Value (message) Int64Value (message) ListValue (message) Method (message) Mixin (message) NullValue (enum) Option (message) SourceContext (message) StringValue (message) Struct (message) Syntax (enum) Timestamp (message) Type (message) UInt32Value (message) UInt64Value (message) Value (message) Well-Known Types that end in &amp;ldquo;Value&amp;rdquo; are wrapper messages for other types, such as BoolValue and EnumValue.</description></item><item><title>Other Languages</title><link>https://protobuf.dev/reference/other/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/other/</guid><description>While the current release includes compilers and APIs for C++, Java, Go, Ruby, C#, and Python, the compiler code is designed so that it&amp;rsquo;s easy to add support for other languages. There are several ongoing projects to add new language implementations to Protocol Buffers, including C, Haskell, Perl, Rust, and more.
For a list of links to projects we know about, see the third-party add-ons wiki page.
Compiler Plugins protoc, the Protocol Buffers Compiler, can be extended to support new languages via plugins.</description></item><item><title>Version Support</title><link>https://protobuf.dev/support/version-support/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/support/version-support/</guid><description>Support windows for protoc and the various languages are covered in the tables later in this topic. Version numbers throughout this topic use SemVer conventions; in the version &amp;ldquo;3.21.7,&amp;rdquo; we say that &amp;ldquo;3&amp;rdquo; is the major version, &amp;ldquo;21&amp;rdquo; is the minor version, and &amp;ldquo;7&amp;rdquo; is the micro or patch number.
Starting with the v20.x protoc release, we changed our versioning scheme to enable nimbler updates to language-specific parts of Protocol Buffers.</description></item><item><title>Migration Guide</title><link>https://protobuf.dev/support/migration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/support/migration/</guid><description>Changes in v30.0 The following is a list of the breaking changes made to versions of the libraries, and how to update your code to accommodate the changes.
This covers breaking changes announced in News Announcements for v30.x and Release Notes for v30.0.
Replaced CMake Submodules with Fetched Deps Previously, our default CMake behavior was to use Git submodules to grab pinned dependencies. Specifying -Dprotobuf_ABSL_PROVIDER=package would flip our CMake configs to look for local installations of Abseil (with similar options for jsoncpp and gtest).</description></item><item><title>Cross-Version Runtime Guarantee</title><link>https://protobuf.dev/support/cross-version-runtime-guarantee/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/support/cross-version-runtime-guarantee/</guid><description>Protobuf language bindings have two components. The generated code (typically produced from protoc) and the runtime libraries that must be included when using the generated code. When these come from different releases of protobuf, we are in a &amp;ldquo;cross version runtime&amp;rdquo; situation.
We intend to offer the following guarantees across all languages except C++ and Rust. These are the default guarantees; however, owners of protobuf code generators and runtimes may explicitly override them with more specific guarantees for that language.</description></item><item><title>Downloads</title><link>https://protobuf.dev/downloads/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/downloads/</guid><description>Release Packages Latest Version The latest release of Protocol Buffers can be found on the release page.
Old Versions Older versions are available in our historical releases on GitHub.
Source Code GitHub Repository Protocol Buffers source code is hosted on GitHub.</description></item><item><title>History</title><link>https://protobuf.dev/history/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/history/</guid><description>Understanding why protobuf was created and the decisions that changed it over time can help you to better use the features of the tool.
Why Did You Release Protocol Buffers? There are several reasons that we released Protocol Buffers.
Protocol buffers are used by many projects inside Google. We had other projects we wanted to release as open source that use protocol buffers, so to do this, we needed to release protocol buffers first.</description></item><item><title>Forum</title><link>https://protobuf.dev/forum-link/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/forum-link/</guid><description/></item><item><title/><link>https://protobuf.dev/navbar/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/navbar/</guid><description> Home Programming Guides Codelabs Reference</description></item><item><title/><link>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/-dsl-list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/-dsl-list/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/DslList/DslList
DslList [JVM] Content fun &amp;lt;E&amp;gt; DslList(delegate: List&amp;lt;E&amp;gt;)</description></item><item><title/><link>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/equals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/equals/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/DslList/equals
equals [JVM] Content open operator override fun equals(other: Any?): Boolean</description></item><item><title/><link>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/hash-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/hash-code/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/DslList/hashCode
hashCode [JVM] Content open override fun hashCode(): Int</description></item><item><title/><link>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/iterator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/iterator/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/DslList/iterator
iterator [JVM] Content open operator override fun iterator(): Iterator&amp;lt;E&amp;gt;</description></item><item><title/><link>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/list-iterator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/list-iterator/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/DslList/listIterator
listIterator [JVM] Content open override fun listIterator(): ListIterator&amp;lt;E&amp;gt; open override fun listIterator(index: Int): ListIterator&amp;lt;E&amp;gt;</description></item><item><title/><link>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/to-string/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/to-string/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/DslList/toString
toString [JVM] Content open override fun toString(): String</description></item><item><title/><link>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/-dsl-map/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/-dsl-map/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/DslMap/DslMap
DslMap [JVM] Content fun &amp;lt;K, V&amp;gt; DslMap(delegate: Map&amp;lt;K, V&amp;gt;)</description></item><item><title/><link>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/entries/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/entries/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/DslMap/entries
entries [JVM] Content open override val entries: Set&amp;lt;Map.Entry&amp;lt;K, V&amp;raquo;</description></item><item><title/><link>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/equals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/equals/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/DslMap/equals
equals [JVM] Content open operator override fun equals(other: Any?): Boolean</description></item><item><title/><link>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/hash-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/hash-code/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/DslMap/hashCode
hashCode [JVM] Content open override fun hashCode(): Int</description></item><item><title/><link>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/keys/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/keys/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/DslMap/keys
keys [JVM] Content open override val keys: Set&amp;lt;K&amp;gt;</description></item><item><title/><link>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/to-string/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/to-string/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/DslMap/toString
toString [JVM] Content open override fun toString(): String</description></item><item><title/><link>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/values/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/values/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/DslMap/values
values [JVM] Content open override val values: Collection&amp;lt;V&amp;gt;</description></item><item><title/><link>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/-extension-list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/-extension-list/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/ExtensionList/ExtensionList
ExtensionList [JVM] Content fun &amp;lt;E, M : MessageLite&amp;gt; ExtensionList(extension: ExtensionLite&amp;lt;M, List&amp;lt;E&amp;raquo;, delegate: List&amp;lt;E&amp;gt;)</description></item><item><title/><link>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/equals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/equals/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/ExtensionList/equals
equals [JVM] Content open operator override fun equals(other: Any?): Boolean</description></item><item><title/><link>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/extension/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/extension/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/ExtensionList/extension
extension [JVM] Content val extension: ExtensionLite&amp;lt;M, List&amp;lt;E&amp;raquo;</description></item><item><title/><link>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/hash-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/hash-code/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/ExtensionList/hashCode
hashCode [JVM] Content open override fun hashCode(): Int</description></item><item><title/><link>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/iterator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/iterator/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/ExtensionList/iterator
iterator [JVM] Content open operator override fun iterator(): Iterator&amp;lt;E&amp;gt;</description></item><item><title/><link>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/list-iterator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/list-iterator/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/ExtensionList/listIterator
listIterator [JVM] Content open override fun listIterator(): ListIterator&amp;lt;E&amp;gt; open override fun listIterator(index: Int): ListIterator&amp;lt;E&amp;gt;</description></item><item><title/><link>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/to-string/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/to-string/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/ExtensionList/toString
toString [JVM] Content open override fun toString(): String</description></item><item><title/><link>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-only-for-use-by-generated-proto-code/-only-for-use-by-generated-proto-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-only-for-use-by-generated-proto-code/-only-for-use-by-generated-proto-code/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/OnlyForUseByGeneratedProtoCode/OnlyForUseByGeneratedProtoCode
OnlyForUseByGeneratedProtoCode [JVM] Content fun OnlyForUseByGeneratedProtoCode()</description></item><item><title/><link>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-proto-dsl-marker/-proto-dsl-marker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-proto-dsl-marker/-proto-dsl-marker/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/ProtoDslMarker/ProtoDslMarker
ProtoDslMarker [JVM] Content fun ProtoDslMarker()</description></item><item><title/><link>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/contains/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/contains/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/contains
contains [JVM] Content operator fun &amp;lt;M : GeneratedMessageV3.ExtendableMessage&amp;lt;M&amp;gt;, MorBT : GeneratedMessageV3.ExtendableMessageOrBuilder&amp;lt;M&amp;raquo; MorBT.contains(extension: ExtensionLite&amp;lt;M, *&amp;gt;): Boolean
Returns true if the specified extension is set on this builder.</description></item><item><title/><link>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/get/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/get/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/get
get [JVM] Content operator fun ByteString.get(index: Int): Byte
Gets the byte at index.
[JVM] Content operator fun &amp;lt;M : GeneratedMessageV3.ExtendableMessage&amp;lt;M&amp;gt;, MorBT : GeneratedMessageV3.ExtendableMessageOrBuilder&amp;lt;M&amp;gt;, T : Any&amp;gt; MorBT.get(extension: ExtensionLite&amp;lt;M, T&amp;gt;): T
Gets the current value of the proto extension.</description></item><item><title/><link>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/is-a/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/is-a/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/isA
isA [JVM] Content inline fun &amp;lt;T : Message&amp;gt; Any.isA(): Boolean
Returns true if this com.google.protobuf.Any contains a message of type T.</description></item><item><title/><link>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/plus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/plus/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/plus
plus [JVM] Content operator fun ByteString.plus(other: ByteString): ByteString \
Concatenates the given ByteString to this one.</description></item><item><title/><link>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/set/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/set/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/set
set [JVM] Content operator fun &amp;lt;M : GeneratedMessageV3.ExtendableMessage&amp;lt;M&amp;gt;, B : GeneratedMessageV3.ExtendableBuilder&amp;lt;M, B&amp;gt;, T : Any&amp;gt; B.set(extension: ExtensionLite&amp;lt;M, T&amp;gt;, value: T)
Sets the current value of the proto extension in this builder.</description></item><item><title/><link>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/to-byte-string-utf8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/to-byte-string-utf8/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/toByteStringUtf8
toByteStringUtf8 [JVM] Content fun String.toByteStringUtf8(): ByteString
Encodes this String into a sequence of UTF-8 bytes and returns the result as a ByteString.</description></item><item><title/><link>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/to-byte-string/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/to-byte-string/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/toByteString
toByteString [JVM] Content fun ByteArray.toByteString(): ByteString
Returns a copy of this ByteArray as an immutable ByteString.
[JVM] Content fun ByteBuffer.toByteString(): ByteString
Copies the remaining bytes from this ByteBuffer to a ByteString.</description></item><item><title/><link>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/unpack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/unpack/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/unpack
unpack [JVM] Content inline fun &amp;lt;T : Message&amp;gt; Any.unpack(): T
Returns the message of type T encoded in this com.google.protobuf.Any.
Throws | | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- | &amp;mdash; InvalidProtocolBufferException | if this com.google.protobuf.Any does not contain a T message.</description></item><item><title>Changes announced April 11, 2023</title><link>https://protobuf.dev/news/2023-04-11/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/2023-04-11/</guid><description>Syntax Reflection Deprecation v23 will deprecate the ability to check syntax version using reflection. The deprecation will be included as warnings at build time. The capability will be removed in a future release.
Adding support for ctype=CORD in C++ v23 will add ctype=CORD support for singular bytes fields, including oneof fields, to specify that data should be stored using absl::cord instead of string. Support may be added in future releases for singular string field types and for repeated string and byte fields if there is enough interest from the open source community.</description></item><item><title>Changes announced April 20, 2023</title><link>https://protobuf.dev/news/2023-04-20/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/2023-04-20/</guid><description>Changes to Ruby Generator This GitHub PR, which will appear in the 23.x release, changes the Ruby code generator to emit a serialized proto instead of the DSL.
It removes the DSL from the code generator in anticipation of splitting the DSL out into a separate package.
Given a .proto file like:
syntax = &amp;#34;proto3&amp;#34;; package pkg; message TestMessage { optional int32 i32 = 1; optional TestMessage msg = 2; } Generated code before:</description></item><item><title>Changes announced April 28, 2023</title><link>https://protobuf.dev/news/2023-04-28/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/2023-04-28/</guid><description>Stricter validation for json_name v24 will forbid embedded null characters in the json_name field option. Going forward, any valid Unicode characters will be accepted, except \u0000. Null will still be allowed in field values.
Previously, the proto compiler allowed null characters, but support for this was inconsistent across languages and implementations. To fix this, we are clarifying the spec to say that null is not allowed in json_name, and will be rejected by the compiler.</description></item><item><title>Changes Announced on August 15, 2023</title><link>https://protobuf.dev/news/2023-08-15/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/2023-08-15/</guid><description>Python Breaking Change In v25 message.UnknownFields() will be deprecated in pure Python and C++ extensions. It will be removed in v26. Use the new UnknownFieldSet(message) support in unknown_fields.py as a replacement.</description></item><item><title>Changes announced August 3, 2022</title><link>https://protobuf.dev/news/2022-08-03/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/2022-08-03/</guid><description>This topic covers two areas: general platform support changes, and C++-specific changes that are being considered for the 22.x release line.
Platform Support Changes We&amp;rsquo;ve added guidance about the platforms that we support in this section of the documentation. The section currently covers C++ and PHP, but may be expanded with information about other platforms in the future.
Official C++ Support Matrix With the policy, mentioned earlier in this announcement, of using Google&amp;rsquo;s official foundational C++ support policy, our C++ compiler and toolchain support matrix will change.</description></item><item><title>Changes Announced on August 9, 2023</title><link>https://protobuf.dev/news/2023-08-09/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/2023-08-09/</guid><description>.NET support policy The Protobuf team supports .NET in two ways:
Generation of C# code by protoc The Google.Protobuf NuGet package, which provides runtime support for the generated code, as well as reflection and other facilities The support policy for these has previously been unclear, particularly in terms of which .NET runtimes are supported. From August 2023 onwards, support will be provided in accordance with the Google Open Source support policy for .</description></item><item><title>arena.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.arena/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.arena/</guid><description>#include &amp;lt;google/protobuf/arena.h&amp;gt;
namespace google::protobuf
This file defines an Arena allocator for better allocation performance. Classes in this fileArenaOptionsArenaOptions provides optional additional parameters to arena construction that control its block-allocation behavior. ArenaArena allocator. Arena::InternalHelperArena::is_arena_constructableHelper typetraits that indicates support for arenas in a type T at compile time. Arena::is_destructor_skippablestruct ArenaOptions#include &amp;lt;google/protobuf/arena.h&amp;gt;
namespace google::protobuf
ArenaOptions provides optional additional parameters to arena construction that control its block-allocation behavior. Memberssize_tstart_block_sizeThis defines the size of the first block requested from the system malloc.</description></item><item><title>common.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.common/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.common/</guid><description>#include &amp;lt;google/protobuf/stubs/common.h&amp;gt;
namespace google::protobuf
Contains basic types and utilities used by the rest of the library. Classes in this file</description></item><item><title>code_generator.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.compiler.code_generator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.compiler.code_generator/</guid><description>#include &amp;lt;google/protobuf/compiler/code_generator.h&amp;gt;
namespace google::protobuf::compiler
Defines the abstract interface implemented by each of the language-specific code generators. Classes in this fileCodeGeneratorThe abstract interface to a class which generates code implementing a particular proto file in a particular language. GeneratorContextCodeGenerators generate one or more files in a given directory. File MembersThese definitions are not part of any class.typedefGeneratorContext OutputDirectoryThe type GeneratorContext was once called OutputDirectory. more...voidParseGeneratorParameter(const std::string &amp;amp; , std::vector&amp;lt; std::pair&amp;lt; std::string, std::string &amp;gt; &amp;gt; * )Several code generators treat the parameter argument as holding a list of options separated by commas.</description></item><item><title>command_line_interface.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.compiler.command_line_interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.compiler.command_line_interface/</guid><description>#include &amp;lt;google/protobuf/compiler/command_line_interface.h&amp;gt;
namespace google::protobuf::compiler
Implements the Protocol Compiler front-end such that it may be reused by custom compilers written to support other languages. Classes in this fileCommandLineInterfaceThis class implements the command-line interface to the protocol compiler. class CommandLineInterface#include &amp;lt;google/protobuf/compiler/command_line_interface.h&amp;gt;
namespace google::protobuf::compiler
This class implements the command-line interface to the protocol compiler. It is designed to make it very easy to create a custom protocol compiler supporting the languages of your choice.</description></item><item><title>cpp_generator.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.compiler.cpp_generator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.compiler.cpp_generator/</guid><description>#include &amp;lt;google/protobuf/compiler/cpp/cpp_generator.h&amp;gt;
namespace google::protobuf::compiler::cpp
Generates C++ code for a given .proto file. Classes in this fileCppGeneratorCodeGenerator implementation which generates a C++ source file and header. class CppGenerator: public CodeGenerator#include &amp;lt;google/protobuf/compiler/cpp/cpp_generator.h&amp;gt;
namespace google::protobuf::compiler::cpp
CodeGenerator implementation which generates a C++ source file and header. If you create your own protocol compiler binary and you want it to support C++ output, you can do so by registering an instance of this CodeGenerator with the CommandLineInterface in your main() function.</description></item><item><title>csharp_generator.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.compiler.csharp_generator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.compiler.csharp_generator/</guid><description>#include &amp;lt;google/protobuf/compiler/csharp/csharp_generator.h&amp;gt;
namespace google::protobuf::compiler::csharp
Generates C# code for a given .proto file. Classes in this fileGeneratorCodeGenerator implementation which generates a C# source file and header. class Generator: public CodeGenerator#include &amp;lt;google/protobuf/compiler/csharp/csharp_generator.h&amp;gt;
namespace google::protobuf::compiler::csharp
CodeGenerator implementation which generates a C# source file and header. If you create your own protocol compiler binary and you want it to support C# output, you can do so by registering an instance of this CodeGenerator with the CommandLineInterface in your main() function.</description></item><item><title>csharp_names.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.compiler.csharp_names/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.compiler.csharp_names/</guid><description>#include &amp;lt;google/protobuf/compiler/csharp/csharp_names.h&amp;gt;
namespace google::protobuf::compiler::csharp
Provides a mechanism for mapping a descriptor to the fully-qualified name of the corresponding C# class. Classes in this fileFile MembersThese definitions are not part of any class.std::stringGetFileNamespace(const FileDescriptor * descriptor)Requires: more...std::stringGetClassName(const Descriptor * descriptor)Requires: more...std::stringGetReflectionClassName(const FileDescriptor * descriptor)Requires: more...std::stringGetOutputFile(const FileDescriptor * descriptor, const std::string file_extension, const bool generate_directories, const std::string base_namespace, std::string * error)Generates output file name for given file descriptor. more... std::string csharp::GetFileNamespace(
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const FileDescriptor * descriptor)Requires: descriptor !</description></item><item><title>importer.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.compiler.importer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.compiler.importer/</guid><description>#include &amp;lt;google/protobuf/compiler/importer.h&amp;gt;
namespace google::protobuf::compiler
This file is the public interface to the .proto file parser. Classes in this fileSourceTreeDescriptorDatabaseAn implementation of DescriptorDatabase which loads files from a SourceTree and parses them. ImporterSimple interface for parsing .proto files. MultiFileErrorCollectorIf the importer encounters problems while trying to import the proto files, it reports them to a MultiFileErrorCollector. SourceTreeAbstract interface which represents a directory tree containing proto files. DiskSourceTreeAn implementation of SourceTree which loads files from locations on disk.</description></item><item><title>java_generator.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.compiler.java_generator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.compiler.java_generator/</guid><description>#include &amp;lt;google/protobuf/compiler/java/java_generator.h&amp;gt;
namespace google::protobuf::compiler::java
Generates Java code for a given .proto file. Classes in this fileJavaGeneratorCodeGenerator implementation which generates Java code. class JavaGenerator: public CodeGenerator#include &amp;lt;google/protobuf/compiler/java/java_generator.h&amp;gt;
namespace google::protobuf::compiler::java
CodeGenerator implementation which generates Java code. If you create your own protocol compiler binary and you want it to support Java output, you can do so by registering an instance of this CodeGenerator with the CommandLineInterface in your main() function. MembersJavaGenerator()~JavaGenerator()implements CodeGeneratorvirtual boolGenerate(const FileDescriptor * file, const std::string &amp;amp; parameter, GeneratorContext * generator_context, std::string * error) constGenerates code for the given proto file, generating one or more files in the given output directory.</description></item><item><title>java_names.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.compiler.java_names/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.compiler.java_names/</guid><description>#include &amp;lt;google/protobuf/compiler/java/java_names.h&amp;gt;
namespace google::protobuf::compiler::java
Provides a mechanism for mapping a descriptor to the fully-qualified name of the corresponding Java class. Classes in this fileFile MembersThese definitions are not part of any class.std::stringClassName(const Descriptor * descriptor)Requires: more...std::stringClassName(const EnumDescriptor * descriptor)Requires: more...std::stringClassName(const FileDescriptor * descriptor)Requires: more...std::stringClassName(const ServiceDescriptor * descriptor)Requires: more...std::stringFileJavaPackage(const FileDescriptor * descriptor)Requires: more...std::stringCapitalizedFieldName(const FieldDescriptor * descriptor)Requires: more... std::string java::ClassName(
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const Descriptor * descriptor)Requires: descriptor != NULL Returns: The fully-qualified Java class name.</description></item><item><title>javanano_generator.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.compiler.javanano_generator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.compiler.javanano_generator/</guid><description>#include &amp;lt;google/protobuf/compiler/javanano/javanano_generator.h&amp;gt;
namespace google::protobuf::compiler::javanano
Generates Java nano code for a given .proto file. Classes in this fileJavaNanoGeneratorCodeGenerator implementation which generates Java nano code. class JavaNanoGenerator: public CodeGenerator#include &amp;lt;google/protobuf/compiler/javanano/javanano_generator.h&amp;gt;
namespace google::protobuf::compiler::javanano
CodeGenerator implementation which generates Java nano code. If you create your own protocol compiler binary and you want it to support Java output for the nano runtime, you can do so by registering an instance of this CodeGenerator with the CommandLineInterface in your main() function.</description></item><item><title>js_generator.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.compiler.js_generator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.compiler.js_generator/</guid><description>#include &amp;lt;google/protobuf/compiler/js/js_generator.h&amp;gt;
namespace google::protobuf::compiler::js
Generates JavaScript code for a given .proto file. Classes in this fileGeneratorOptionsGeneratorCodeGenerator implementation which generates a JavaScript source file and header. struct GeneratorOptions#include &amp;lt;google/protobuf/compiler/js/js_generator.h&amp;gt;
namespace google::protobuf::compiler::js
MembersenumImportStyleWhat style of imports should be used. more...enumOutputMode more...std::stringoutput_dirOutput path. std::stringnamespace_prefixNamespace prefix. boolbinaryEnable binary-format support? enum google::protobuf::compiler::js::GeneratorOptions::ImportStyleimport_stylebooladd_require_for_enumsAdd a goog.requires() call for each enum type used. more...booltestonlySet this as a test-only module via goog.setTestOnly();. std::stringlibraryCreate a library with name &amp;lt;name&amp;gt;_lib.js rather than a separate .</description></item><item><title>objectivec_generator.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.compiler.objectivec_generator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.compiler.objectivec_generator/</guid><description>#include &amp;lt;google/protobuf/compiler/objectivec/objectivec_generator.h&amp;gt;
namespace google::protobuf::compiler::objectivec
Generates ObjectiveC code for a given .proto file. Classes in this fileObjectiveCGeneratorCodeGenerator implementation which generates a ObjectiveC source file and header. class ObjectiveCGenerator: public CodeGenerator#include &amp;lt;google/protobuf/compiler/objectivec/objectivec_generator.h&amp;gt;
namespace google::protobuf::compiler::objectivec
CodeGenerator implementation which generates a ObjectiveC source file and header. If you create your own protocol compiler binary and you want it to support ObjectiveC output, you can do so by registering an instance of this CodeGenerator with the CommandLineInterface in your main() function.</description></item><item><title>objectivec_helpers.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.compiler.objectivec_helpers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.compiler.objectivec_helpers/</guid><description>#include &amp;lt;google/protobuf/compiler/objectivec/objectivec_helpers.h&amp;gt;
namespace google::protobuf::compiler::objectivec
Helper functions for generating ObjectiveC code. Classes in this fileOptionsGenerator options (see objectivec_generator.cc for a description of each): TextFormatDecodeDataGenerate decode data needed for ObjC's GPBDecodeTextFormatName() to transform the input into the expected output. LineConsumerHelper for parsing simple files. ImportWriterHelper class for parsing framework import mappings and generating import statements. File MembersThese definitions are not part of any class.enumObjectiveCType more...enumFlagType more...const char *constProtobufLibraryFrameworkNameThe name the commonly used by the library when built as a framework.</description></item><item><title>parser.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.compiler.parser/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.compiler.parser/</guid><description>#include &amp;lt;google/protobuf/compiler/parser.h&amp;gt;
namespace google::protobuf::compiler
Implements parsing of .proto files to FileDescriptorProtos. Classes in this fileParserImplements parsing of protocol definitions (such as .proto files). SourceLocationTableA table mapping (descriptor, ErrorLocation) pairs &amp;ndash; as reported by DescriptorPool when validating descriptors &amp;ndash; to line and column numbers within the original source code. class Parser#include &amp;lt;google/protobuf/compiler/parser.h&amp;gt;
namespace google::protobuf::compiler
Implements parsing of protocol definitions (such as .proto files). Note that most users will be more interested in the Importer class.</description></item><item><title>plugin.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.compiler.plugin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.compiler.plugin/</guid><description>#include &amp;lt;google/protobuf/compiler/plugin.h&amp;gt;
namespace google::protobuf::compiler
Front-end for protoc code generator plugins written in C++. To implement a protoc plugin in C++, simply write an implementation of CodeGenerator, then create a main() function like: int main(int argc, char* argv[]) { MyCodeGenerator generator; return google::protobuf::compiler::PluginMain(argc, argv, &amp;amp;generator); } You must link your plugin against libprotobuf and libprotoc.
The core part of PluginMain is to invoke the given CodeGenerator on a CodeGeneratorRequest to generate a CodeGeneratorResponse.</description></item><item><title>plugin.pb.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.compiler.plugin.pb/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.compiler.plugin.pb/</guid><description>#include &amp;lt;google/protobuf/compiler/plugin.pb.h&amp;gt;
namespace google::protobuf::compiler
API for protoc plugins.
This file defines a set of protocol message classes which make up the API to protoc code generator plugins. Plugins written in C++ should probably build on the API in plugin.h instead of dealing with the protobuf-level API, but plugins in other languages will need to deal with the raw messages as defined below.
The protocol compiler currently doesn't support auto-generated documentation, hence this page contains no descriptions.</description></item><item><title>python_generator.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.compiler.python_generator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.compiler.python_generator/</guid><description>#include &amp;lt;google/protobuf/compiler/python/python_generator.h&amp;gt;
namespace google::protobuf::compiler::python
Generates Python code for a given .proto file. Classes in this fileGeneratorCodeGenerator implementation for generated Python protocol buffer classes. class Generator: public CodeGenerator#include &amp;lt;google/protobuf/compiler/python/python_generator.h&amp;gt;
namespace google::protobuf::compiler::python
CodeGenerator implementation for generated Python protocol buffer classes. If you create your own protocol compiler binary and you want it to support Python output, you can do so by registering an instance of this CodeGenerator with the CommandLineInterface in your main() function.</description></item><item><title>ruby_generator.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.compiler.ruby_generator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.compiler.ruby_generator/</guid><description>#include &amp;lt;google/protobuf/compiler/ruby/ruby_generator.h&amp;gt;
namespace google::protobuf::compiler::ruby
Generates Ruby code for a given .proto file. Classes in this fileGeneratorCodeGenerator implementation for generated Ruby protocol buffer classes. class Generator: public CodeGenerator#include &amp;lt;google/protobuf/compiler/ruby/ruby_generator.h&amp;gt;
namespace google::protobuf::compiler::ruby
CodeGenerator implementation for generated Ruby protocol buffer classes. If you create your own protocol compiler binary and you want it to support Ruby output, you can do so by registering an instance of this CodeGenerator with the CommandLineInterface in your main() function.</description></item><item><title>descriptor.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.descriptor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.descriptor/</guid><description>#include &amp;lt;google/protobuf/descriptor.h&amp;gt;
namespace google::protobuf
This file contains classes which describe a type of protocol message. You can use a message's descriptor to learn at runtime what fields it contains and what the types of those fields are. The Message interface also allows you to dynamically access and modify individual fields by passing the FieldDescriptor of the field you are interested in.
Most users will not care about descriptors, because they will write code specific to certain protocol types and will simply use the classes generated by the protocol compiler directly.</description></item><item><title>descriptor.pb.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.descriptor.pb/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.descriptor.pb/</guid><description>#include &amp;lt;google/protobuf/descriptor.pb.h&amp;gt;
namespace google::protobuf
Protocol buffer representations of descriptors.
This file defines a set of protocol message classes which represent the same information represented by the classes defined in descriptor.h. You can convert a FileDescriptorProto to a FileDescriptor using the DescriptorPool class. Thus, the classes in this file allow protocol type definitions to be communicated efficiently between processes.
The protocol compiler currently doesn't support auto-generated documentation, hence this page contains no descriptions.</description></item><item><title>descriptor_database.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.descriptor_database/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.descriptor_database/</guid><description>#include &amp;lt;google/protobuf/descriptor_database.h&amp;gt;
namespace google::protobuf
Interface for manipulating databases of descriptors. Classes in this fileDescriptorDatabaseAbstract interface for a database of descriptors. SimpleDescriptorDatabaseA DescriptorDatabase into which you can insert files manually. EncodedDescriptorDatabaseVery similar to SimpleDescriptorDatabase, but stores all the descriptors as raw bytes and generally tries to use as little memory as possible. DescriptorPoolDatabaseA DescriptorDatabase that fetches files from a given pool. MergedDescriptorDatabaseA DescriptorDatabase that wraps two or more others. class DescriptorDatabase#include &amp;lt;google/protobuf/descriptor_database.</description></item><item><title>dynamic_message.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.dynamic_message/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.dynamic_message/</guid><description>#include &amp;lt;google/protobuf/dynamic_message.h&amp;gt;
namespace google::protobuf
Defines an implementation of Message which can emulate types which are not known at compile-time. Classes in this fileDynamicMessageFactoryConstructs implementations of Message which can emulate types which are not known at compile-time. DynamicMapSorterHelper for computing a sorted list of map entries via reflection. class DynamicMessageFactory: public MessageFactory#include &amp;lt;google/protobuf/dynamic_message.h&amp;gt;
namespace google::protobuf
Constructs implementations of Message which can emulate types which are not known at compile-time. Sometimes you want to be able to manipulate protocol types that you don't know about at compile time.</description></item><item><title>coded_stream.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.io.coded_stream/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.io.coded_stream/</guid><description>#include &amp;lt;google/protobuf/io/coded_stream.h&amp;gt;
namespace google::protobuf::io
This file contains the CodedInputStream and CodedOutputStream classes, which wrap a ZeroCopyInputStream or ZeroCopyOutputStream, respectively, and allow you to read or write individual pieces of data in various formats. In particular, these implement the varint encoding for integers, a simple variable-length encoding in which smaller numbers take fewer bytes.
Typically these classes will only be used internally by the protocol buffer library in order to encode and decode protocol buffers.</description></item><item><title>gzip_stream.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.io.gzip_stream/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.io.gzip_stream/</guid><description>#include &amp;lt;google/protobuf/io/gzip_stream.h&amp;gt;
namespace google::protobuf::io
This file contains the definition for classes GzipInputStream and GzipOutputStream. GzipInputStream decompresses data from an underlying ZeroCopyInputStream and provides the decompressed data as a ZeroCopyInputStream.
GzipOutputStream is an ZeroCopyOutputStream that compresses data to an underlying ZeroCopyOutputStream. Classes in this fileGzipInputStreamA ZeroCopyInputStream that reads compressed data through zlib. GzipOutputStreamGzipOutputStream::Optionsclass GzipInputStream: public ZeroCopyInputStream#include &amp;lt;google/protobuf/io/gzip_stream.h&amp;gt;
namespace google::protobuf::io
A ZeroCopyInputStream that reads compressed data through zlib. MembersenumFormatFormat key for constructor. more.</description></item><item><title>printer.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.io.printer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.io.printer/</guid><description>#include &amp;lt;google/protobuf/io/printer.h&amp;gt;
namespace google::protobuf::io
Utility class for writing text to a ZeroCopyOutputStream. Classes in this fileAnnotationCollectorRecords annotations about a Printer's output. AnnotationProtoCollectorRecords annotations about a Printer's output to the given protocol buffer, assuming that the buffer has an ::Annotation message exposing path, source_file, begin and end fields. Printerclass AnnotationCollector#include &amp;lt;google/protobuf/io/printer.h&amp;gt;
namespace google::protobuf::io
Records annotations about a Printer's output. Known subclasses:
AnnotationProtoCollector&lt; AnnotationProto >Memberstypedefstd::pair&amp;lt; std::pair&amp;lt; size_t, size_t &amp;gt;, std::string &amp;gt; AnnotationAnnotation is a offset range and a payload pair.</description></item><item><title>tokenizer.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.io.tokenizer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.io.tokenizer/</guid><description>#include &amp;lt;google/protobuf/io/tokenizer.h&amp;gt;
namespace google::protobuf::io
Class for parsing tokenized text from a ZeroCopyInputStream. Classes in this fileErrorCollectorAbstract interface for an object which collects the errors that occur during parsing. TokenizerThis class converts a stream of raw text into a stream of tokens for the protocol definition parser to parse. Tokenizer::TokenStructure representing a token read from the token stream. File MembersThese definitions are not part of any class.typedefint ColumnNumberBy "column number", the proto compiler refers to a count of the number of bytes before a given byte, except that a tab character advances to the next multiple of 8 bytes.</description></item><item><title>zero_copy_stream.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream/</guid><description>#include &amp;lt;google/protobuf/io/zero_copy_stream.h&amp;gt;
namespace google::protobuf::io
This file contains the ZeroCopyInputStream and ZeroCopyOutputStream interfaces, which represent abstract I/O streams to and from which protocol buffers can be read and written. For a few simple implementations of these interfaces, see zero_copy_stream_impl.h.
These interfaces are different from classic I/O streams in that they try to minimize the amount of data copying that needs to be done. To accomplish this, responsibility for allocating buffers is moved to the stream object, rather than being the responsibility of the caller.</description></item><item><title>zero_copy_stream_impl.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream_impl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream_impl/</guid><description>#include &amp;lt;google/protobuf/io/zero_copy_stream_impl.h&amp;gt;
namespace google::protobuf::io
This file contains common implementations of the interfaces defined in zero_copy_stream.h which are only included in the full (non-lite) protobuf library. These implementations include Unix file descriptors and C++ iostreams. See also: zero_copy_stream_impl_lite.h Classes in this fileFileInputStreamA ZeroCopyInputStream which reads from a file descriptor. FileOutputStreamA ZeroCopyOutputStream which writes to a file descriptor. IstreamInputStreamA ZeroCopyInputStream which reads from a C++ istream. OstreamOutputStreamA ZeroCopyOutputStream which writes to a C++ ostream.</description></item><item><title>zero_copy_stream_iml_lite.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream_impl_lite/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream_impl_lite/</guid><description>#include &amp;lt;google/protobuf/io/zero_copy_stream_impl_lite.h&amp;gt;
namespace google::protobuf::io
This file contains common implementations of the interfaces defined in zero_copy_stream.h which are included in the "lite" protobuf library. These implementations cover I/O on raw arrays and strings, as well as adaptors which make it easy to implement streams based on traditional streams. Of course, many users will probably want to write their own implementations of these interfaces specific to the particular I/O abstractions they prefer to use, but these should cover the most common cases.</description></item><item><title>map.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.map/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.map/</guid><description>#include &amp;lt;google/protobuf/map.h&amp;gt;
namespace google::protobuf
This file defines the map container and its helpers to support protobuf maps. The Map and MapIterator types are provided by this header file. Please avoid using other types defined here, unless they are public types within Map or MapIterator, such as Map::value_type. Classes in this fileMapPairThis is the class for Map's internal value_type. MapMap is an associative container type used to store protobuf map fields. Map::const_iteratorIterators.</description></item><item><title>message.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.message/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.message/</guid><description>#include &amp;lt;google/protobuf/message.h&amp;gt;
namespace google::protobuf
Defines Message, the abstract interface implemented by non-lite protocol message objects. Although it's possible to implement this interface manually, most users will use the protocol compiler to generate implementations.
Example usage:
Say you have a message defined as:
message Foo { optional string text = 1; repeated int32 numbers = 2; } Then, if you used the protocol compiler to generate a class from the above definition, you could use it like so:</description></item><item><title>message_lite.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.message_lite/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.message_lite/</guid><description>#include &amp;lt;google/protobuf/message_lite.h&amp;gt;
namespace google::protobuf
Defines MessageLite, the abstract interface implemented by all (lite and non-lite) protocol message objects. Classes in this fileMessageLiteInterface to light weight protocol messages. File MembersThese definitions are not part of any class.voidShutdownProtobufLibrary()Shut down the entire protocol buffers library, deleting all static-duration objects allocated by the library or by generated .pb.cc files. more... void protobuf::ShutdownProtobufLibrary()Shut down the entire protocol buffers library, deleting all static-duration objects allocated by the library or by generated .</description></item><item><title>repeated_field.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.repeated_field/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.repeated_field/</guid><description>#include &amp;lt;google/protobuf/repeated_field.h&amp;gt;
namespace google::protobuf
RepeatedField and RepeatedPtrField are used by generated protocol message classes to manipulate repeated fields. These classes are very similar to STL's vector, but include a number of optimizations found to be useful specifically in the case of Protocol Buffers. RepeatedPtrField is particularly different from STL vector as it manages ownership of the pointers that it contains.
Typically, clients should not need to access RepeatedField objects directly, but should instead use the accessor functions generated automatically by the protocol compiler.</description></item><item><title>service.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.service/</guid><description>#include &amp;lt;google/protobuf/service.h&amp;gt;
namespace google::protobuf
DEPRECATED: This module declares the abstract interfaces underlying proto2 RPC services. These are intended to be independent of any particular RPC implementation, so that proto2 services can be used on top of a variety of implementations. Starting with version 2.3.0, RPC implementations should not try to build on these, but should instead provide code generator plugins which generate code specific to the particular RPC implementation. This way the generated code can be more appropriate for the implementation in use and can avoid unnecessary layers of indirection.</description></item><item><title>text_format.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.text_format/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.text_format/</guid><description>#include &amp;lt;google/protobuf/text_format.h&amp;gt;
namespace google::protobuf
Utilities for printing and parsing protocol messages in a human-readable, text-based format. Classes in this fileTextFormatThis class implements protocol buffer text format, colloquially known as text proto. TextFormat::BaseTextGeneratorTextFormat::FastFieldValuePrinterThe default printer that converts scalar values from fields into their string representation. TextFormat::FieldValuePrinterDeprecated: please use FastFieldValuePrinter instead. TextFormat::FinderInterface that Printers or Parsers can use to find extensions, or types referenced in Any messages. TextFormat::MessagePrinterTextFormat::ParseInfoTreeData structure which is populated with the locations of each field value parsed from the text.</description></item><item><title>unknown_field_set.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.unknown_field_set/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.unknown_field_set/</guid><description>#include &amp;lt;google/protobuf/unknown_field_set.h&amp;gt;
namespace google::protobuf
Contains classes used to keep track of unrecognized fields seen while parsing a protocol message. Classes in this fileUnknownFieldSetAn UnknownFieldSet contains fields that were encountered while parsing a message but were not defined by its type. UnknownFieldRepresents one field in an UnknownFieldSet. UnknownField::LengthDelimitedclass UnknownFieldSet#include &amp;lt;google/protobuf/unknown_field_set.h&amp;gt;
namespace google::protobuf
An UnknownFieldSet contains fields that were encountered while parsing a message but were not defined by its type. Keeping track of these can be useful, especially in that they may be written if the message is serialized again without being cleared in between.</description></item><item><title>field_comparator.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.util.field_comparator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.util.field_comparator/</guid><description>#include &amp;lt;google/protobuf/util/field_comparator.h&amp;gt;
namespace google::protobuf::util
Defines classes for field comparison. Classes in this fileFieldComparatorBase class specifying the interface for comparing protocol buffer fields. SimpleFieldComparatorBasic implementation of FieldComparator. DefaultFieldComparatorclass FieldComparator#include &amp;lt;google/protobuf/util/field_comparator.h&amp;gt;
namespace google::protobuf::util
Base class specifying the interface for comparing protocol buffer fields. Regular users should consider using or subclassing DefaultFieldComparator rather than this interface. Currently, this does not support comparing unknown fields. Known subclasses:
SimpleFieldComparatorMembersenumComparisonResult more...FieldComparator()virtual ~FieldComparator()virtual ComparisonResultCompare(const Message &amp;amp; message_1, const Message &amp;amp; message_2, const FieldDescriptor * field, int index_1, int index_2, const util::FieldContext * field_context) = 0Compares the values of a field in two protocol buffer messages.</description></item><item><title>field_mask_util.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.util.field_mask_util/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.util.field_mask_util/</guid><description>#include &amp;lt;google/protobuf/util/field_mask_util.h&amp;gt;
namespace google::protobuf::util
Defines utilities for the FieldMask well known type. Classes in this fileFieldMaskUtilFieldMaskUtil::MergeOptionsFieldMaskUtil::TrimOptionsclass FieldMaskUtil#include &amp;lt;google/protobuf/util/field_mask_util.h&amp;gt;
namespace google::protobuf::util
Membersstatic std::stringToString(const FieldMask &amp;amp; mask)Converts FieldMask to/from string, formatted by separating each path with a comma (e.g., "foo_bar,baz.quz"). static voidFromString(StringPiece str, FieldMask * out)template static voidFromFieldNumbers(const std::vector&amp;lt; int64_t &amp;gt; &amp;amp; field_numbers, FieldMask * out)Populates the FieldMask with the paths corresponding to the fields with the given numbers, after checking that all field numbers are valid.</description></item><item><title>json_util.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.util.json_util/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.util.json_util/</guid><description>#include &amp;lt;google/protobuf/util/json_util.h&amp;gt;
namespace google::protobuf::util
Utility functions to convert between protobuf binary format and proto3 JSON format. Classes in this fileJsonParseOptionsJsonPrintOptionsFile MembersThese definitions are not part of any class.typedefJsonPrintOptions JsonOptionsDEPRECATED. Use JsonPrintOptions instead. util::StatusMessageToJsonString(const Message &amp;amp; message, std::string * output, const JsonOptions &amp;amp; options)Converts from protobuf message to JSON and appends it to |output|. more...util::StatusMessageToJsonString(const Message &amp;amp; message, std::string * output)util::StatusJsonStringToMessage(StringPiece input, Message * message, const JsonParseOptions &amp;amp; options)Converts from JSON to protobuf message.</description></item><item><title>message_differencer.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.util.message_differencer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.util.message_differencer/</guid><description>#include &amp;lt;google/protobuf/util/message_differencer.h&amp;gt;
namespace google::protobuf::util
This file defines static methods and classes for comparing Protocol Messages. Aug. 2008: Added Unknown Fields Comparison for messages. Aug. 2009: Added different options to compare repeated fields. Apr. 2010: Moved field comparison to FieldComparator Sep. 2020: Added option to output map keys in path Classes in this fileMessageDifferencerA basic differencer that can be used to determine the differences between two specified Protocol Messages. MessageDifferencer::IgnoreCriteriaAbstract base class from which all IgnoreCriteria derive.</description></item><item><title>time_util.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.util.time_util/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.util.time_util/</guid><description>#include &amp;lt;google/protobuf/util/time_util.h&amp;gt;
namespace google::protobuf::util
Defines utilities for the Timestamp and Duration well known types. Classes in this fileTimeUtilUtility functions for Timestamp and Duration. class TimeUtil#include &amp;lt;google/protobuf/util/time_util.h&amp;gt;
namespace google::protobuf::util
Utility functions for Timestamp and Duration. Membersconst int64_tkTimestampMinSeconds = = -62135596800LLThe min/max Timestamp/Duration values we support. more...const int64_tkTimestampMaxSeconds = = 253402300799LLFor "9999-12-31T23:59:59.999999999Z". const int64_tkDurationMinSeconds = = -315576000000LLconst int64_tkDurationMaxSeconds = = 315576000000LLstatic std::stringToString(const Timestamp &amp;amp; timestamp)Converts Timestamp to/from RFC 3339 date string format. more.</description></item><item><title>type_resolver.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.util.type_resolver/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.util.type_resolver/</guid><description>#include &amp;lt;google/protobuf/util/type_resolver.h&amp;gt;
namespace google::protobuf::util
Defines a TypeResolver for the Any message. Classes in this fileTypeResolverAbstract interface for a type resolver. class TypeResolver#include &amp;lt;google/protobuf/util/type_resolver.h&amp;gt;
namespace google::protobuf::util
Abstract interface for a type resolver. Implementations of this interface must be thread-safe. MembersTypeResolver()virtual ~TypeResolver()virtual util::StatusResolveMessageType(const std::string &amp;amp; type_url, google::protobuf::Type * message_type) = 0Resolves a type url for a message type. virtual util::StatusResolveEnumType(const std::string &amp;amp; type_url, google::protobuf::Enum * enum_type) = 0Resolves a type url for an enum type.</description></item><item><title>type_resolver_util.h</title><link>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.util.type_resolver_util/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/reference/cpp/api-docs/google.protobuf.util.type_resolver_util/</guid><description>#include &amp;lt;google/protobuf/util/type_resolver_util.h&amp;gt;
namespace google::protobuf::util
Defines utilities for the TypeResolver. Classes in this fileFile MembersThese definitions are not part of any class.TypeResolver *NewTypeResolverForDescriptorPool(const std::string &amp;amp; url_prefix, const DescriptorPool * pool)Creates a TypeResolver that serves type information in the given descriptor pool. more... TypeResolver * util::NewTypeResolverForDescriptorPool(
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const std::string &amp;amp; url_prefix,
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const DescriptorPool * pool)Creates a TypeResolver that serves type information in the given descriptor pool. Caller takes ownership of the returned TypeResolver.</description></item><item><title>Changes announced on December 13, 2023</title><link>https://protobuf.dev/news/2023-12-13/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/2023-12-13/</guid><description>C++ Breaking Changes In v26, we are planning a major version bump for C++ as per our breaking changes policy and version support policy.
The following sections outline the set of breaking changes that we plan to include in the 26.0 release of protocol buffers. Note that plans can and do change. These are potential breaking changes to be aware of, but they may not happen in this particular release, or they may not happen at all.</description></item><item><title>Changes announced December 13, 2024</title><link>https://protobuf.dev/news/2024-12-13/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/2024-12-13/</guid><description>Removing a Reflection-related Function In v30.x, we are removing the following reflection-related function: MutableRepeatedFieldRef&amp;lt;T&amp;gt;::Reserve().
An upcoming performance improvement in RepeatedPtrField is incompatible with this API. The improvement is projected to accelerate repeated access to the elements of RepeatedPtrField, in particular and especially sequential access.</description></item><item><title>Changes announced December 18, 2024</title><link>https://protobuf.dev/news/2024-12-18/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/2024-12-18/</guid><description>Go Protobuf: The new Opaque API Back in March 2020, we released the google.golang.org/protobuf module, a major overhaul of the Go Protobuf API. This package introduced first-class support for reflection, a dynamicpb implementation and the protocmp package for easier testing.
That release introduced a new protobuf module with a new API. Today, we are releasing an additional API for generated code, meaning the Go code in the .pb.go files created by the protocol compiler (protoc).</description></item><item><title>Changes announced on December 27, 2023</title><link>https://protobuf.dev/news/2023-12-27/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/2023-12-27/</guid><description>Ruby Breaking Changes The following changes are planned for the 26.x line:
Fix RepeatedField#each_index to have the correct semantics. (#11767) Remove Ruby DSL and associated compatibility code, which will complete the migration announced in April. Message#to_h fixes: Remove unset oneof fields. (#6167) Remove unset sub-message fields Use message&amp;rsquo;s pool for encode_json/decode_json. Remove the deprecated syntax accessor, FileDescriptor.syntax and add semantic checks in its place: FieldDescriptor.has_presence to test if a field has presence.</description></item><item><title>Changes announced December 4, 2024</title><link>https://protobuf.dev/news/2024-12-04/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/2024-12-04/</guid><description>We are planning to modify the Protobuf debug APIs for C++ (including Protobuf AbslStringify, proto2::ShortFormat, proto2::Utf8Format, Message::DebugString, Message::ShortDebugString, Message::Utf8DebugString) in v30 to redact sensitive fields annotated by debug_redact; the outputs of these APIs will contain a per-process randomized prefix, and so will no longer be parseable by Protobuf TextFormat Parsers.
Motivation Currently Protobuf debug APIs print every field in a proto into human-readable formats. This may lead to privacy incidents where developers accidentally log Protobuf debug outputs containing sensitive fields.</description></item><item><title>Changes announced on December 5, 2023</title><link>https://protobuf.dev/news/2023-12-05/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/2023-12-05/</guid><description>Java Breaking Changes In v26, we are planning a major version bump for Java per our breaking changes policy and version support policy.
The following sections outline the set of breaking changes that we plan to include in the 26.0 release of protocol buffers. Note that plans can and do change. These are potential breaking changes to be aware of, but they may not happen in this particular release, or they may not happen at all.</description></item><item><title>Changes Announced on February 27, 2024</title><link>https://protobuf.dev/news/2024-02-27/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/2024-02-27/</guid><description>Dropping Ruby 2.7 Support As per our official Ruby support policy, we will be dropping support for Ruby 2.7 and lower on March 31, 2024. The minimum supported Ruby version will be 3.0.</description></item><item><title>Changes announced February 5, 2024</title><link>https://protobuf.dev/news/2024-02-05/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/2024-02-05/</guid><description>This topic covers breaking changes in Java, C++, and Python in the 26.x line.
JSON Formatter Option Changes Starting in the 26.x line, the JSON formatter option to print default-valued fields is replaced with a fixed way to handle proto2 and proto3 optional fields consistently.
Java: includingDefaultValueFields() is replaced with alwaysPrintFieldsWithNoPresence(). C++: always_print_default_values is replaced with always_print_fields_with_no_presence=True. Py: including_default_value_fields=True is replaced with always_print_fields_with_no_presence=True. The new flag behaves identically to the old flag on proto3 messages, but no longer applies to proto2 optional fields.</description></item><item><title>Changes announced January 23, 2025</title><link>https://protobuf.dev/news/2025-01-23/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/2025-01-23/</guid><description>Poison Java gencode We are patching a change into the 25.x branch that will poison Java gencode that was created prior to the 3.21.7 release. We will then mark all versions of Java protobuf from 3.21.7 through 3.25.5 as vulnerable to the footmitten CVE.
After this change is patched in, protobuf will throw an UnsupportedOperationException from the makeExtensionsImmutable method unless you set the system property &amp;ldquo;-Dcom.google.protobuf.use_unsafe_pre22_gencode&amp;rdquo;. Using this system property can buy you some time if you can&amp;rsquo;t update your code immediately, but should be considered a short-term workaround.</description></item><item><title>Changes announced January 31, 2024</title><link>https://protobuf.dev/news/2024-01-31/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/2024-01-31/</guid><description>This topic covers breaking changes in Python in the 26.x line.
Python Breaking Changes Removing setup.py and setup.cfg support from GitHub In the 26.x release, setup.py and setup.cfg will no longer be present in the python/ directory of the GitHub repository or GitHub release tarballs. This means it will no longer be possible to build a Python package directly from the GitHub repo or release tarball.
The Python source packages published on PyPI will continue to have a setup.</description></item><item><title>Changes announced January 5, 2024</title><link>https://protobuf.dev/news/2024-01-05/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/2024-01-05/</guid><description>This topic covers breaking changes in Ruby and Python in the 26.x line.
Ruby Breaking Changes Freeze Is Now Recursive in Ruby Starting in the 26.x line, when freeze is applied it will be applied recursively, affecting all sub-messages, maps, and repeated fields.
Python Breaking Changes Removing Deprecated APIs In the 26.x release, the following deprecated APIs will be removed:
AddFileDescriptor AddDescriptor AddEnumDescriptor AddExtensionDescriptor AddServiceDescriptor Rejecting Extend Repeated Field with None Iterable Starting in the 26.</description></item><item><title>Changes Announced on July 17, 2023</title><link>https://protobuf.dev/news/2023-07-17/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/2023-07-17/</guid><description>Dropping Bazel 5.x Support As per our official support policy, we will be dropping support for Bazel 5.x and lower. This means the minimum supported Bazel version is 6.2.x.</description></item><item><title>Changes announced July 6, 2022</title><link>https://protobuf.dev/news/2022-07-06/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/2022-07-06/</guid><description>Library Breaking Change Policy Google released its OSS Library Breaking Change Policy, which some Google-sponsored open source projects have opted into. Protocol buffers has adopted this policy.</description></item><item><title>Changes Announced on July 6, 2023</title><link>https://protobuf.dev/news/2023-07-06/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/2023-07-06/</guid><description>Dropping PHP 7.x Support As per our official PHP support policy, we will be dropping support for PHP 7.4 and lower. This means the minimum supported PHP version is 8.0.
If you are running an older version of PHP, you can install a previous release of the protobuf PHP extension by running pecl install protobuf-3.23.3.
Dropping Ruby 2.6 Support As per our official Ruby support policy, we will be dropping support for Ruby 2.</description></item><item><title>Changes Announced on June 26, 2024</title><link>https://protobuf.dev/news/2024-06-26/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/2024-06-26/</guid><description>Dropping Support for Building Protobuf Java from Source with Maven We are planning to drop support for building Protobuf Java OSS from source with the Maven build system in the Protobuf Java 4.28 release. This has been marked deprecated in the 4.27 release.
After this point, you can continue to use Bazel, or another build system, to build Protobuf. You can read more about building from source in the Protobuf Java README.</description></item><item><title>Changes Announced on June 29, 2023</title><link>https://protobuf.dev/news/2023-06-29/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/2023-06-29/</guid><description>TL;DR: We are planning to release Protobuf Editions to the open source project in the second half of 2023. While there is no requirement to move from proto2/proto3 syntax to Editions syntax at initial release, we encourage you to plan a move in your software project&amp;rsquo;s future timeline.
Protobuf Editions Protobuf Editions replace the proto2 and proto3 designations that we have used for Protocol Buffers. Instead of adding syntax = &amp;quot;proto2&amp;quot; or syntax = &amp;quot;proto3&amp;quot; at the top of proto definition files, you use an edition number, such as edition = &amp;quot;2024&amp;quot;, to specify the default behaviors your file will have.</description></item><item><title>Changes Announced on March 18, 2025</title><link>https://protobuf.dev/news/2025-03-18/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/2025-03-18/</guid><description>Dropping Ruby 3.0 Support As per our official Ruby support policy, we will be dropping support for Ruby 3.0 and lower in Protobuf version 31, due to release in April, 2025. The minimum supported Ruby version will be 3.1.</description></item><item><title>Changes announced May 6, 2022</title><link>https://protobuf.dev/news/2022-05-06/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/2022-05-06/</guid><description>Versioning We changed our versioning scheme to enable more-nimble updates to language-specific parts of Protocol Buffers. In the new scheme, each language has its own major version that can be incremented independently of other languages, as covered later in this topic with the Python release. The minor and patch versions, however, will remain coupled. This allows us to introduce breaking changes into some languages without requiring a bump of the major version in languages that do not experience a breaking change.</description></item><item><title>Changes Announced on November 7, 2024</title><link>https://protobuf.dev/news/2024-11-07/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/2024-11-07/</guid><description>The following sections cover planned breaking changes in the v30 release, expected in 2025 Q1. Also included are some changes that aren&amp;rsquo;t breaking but may require action on your part. These are in addition to those mentioned in the News article from October 2.
These describe changes as we anticipate them being implemented, but due to the flexible nature of software some of these changes may not land or may vary from how they are described in this topic.</description></item><item><title>Changes Announced on October 1, 2024</title><link>https://protobuf.dev/news/2024-10-01/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/2024-10-01/</guid><description>Bazel and Proto Rules There are upcoming changes to the way that Bazel will work for protobuf builds. These changes require awareness in the first stage, and action by project owners before the second stage.
Stage 1 With the release of Bazel 8, proto rules (proto_library, cc_proto_library, java_proto_library, java_lite_proto_library, and py_proto_library) will be removed from the Bazel project. The will be added to the Protocol Buffers project in v29. Bazel will be updated to automatically use the rules from the protobuf project, so the change is initially a no-op for project owners.</description></item><item><title>Changes announced on October 10, 2023</title><link>https://protobuf.dev/news/2023-10-10/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/2023-10-10/</guid><description>Protobuf Editions Features Documentation that introduces Protobuf Editions features is now available.</description></item><item><title>Changes Announced on October 2, 2024</title><link>https://protobuf.dev/news/2024-10-02/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/2024-10-02/</guid><description>The following sections cover planned breaking changes in the v30 release, expected in 2025 Q1. These describe changes as we anticipate them being implemented, but due to the flexible nature of software some of these changes may not land or may vary from how they are described in this topic.
Changes in C++ C++ will bump its major version from 5.29.x to 6.30.x.
Descriptor APIs v30 will update return types in descriptor (such as full_name) to be absl::string_view.</description></item><item><title>Search Results</title><link>https://protobuf.dev/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/search/</guid><description/></item><item><title>Changes announced on September 15, 2023</title><link>https://protobuf.dev/news/2023-09-15/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/2023-09-15/</guid><description>μpb Moving to the Protobuf Git Repository Starting with the v25 release, μpb now lives in the protobuf repo instead of in its former location in a separate repo. All μpb development going forward will take place only in the new location.
The merger of the two repos will simplify and speed up our development process by removing the need to update pinned version dependencies between protobuf and μpb. Changes to μpb now take effect immediately in protobuf code and vice versa, without the need for a manual upgrade step.</description></item><item><title>News Announcements for Version 21.x</title><link>https://protobuf.dev/news/v21/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/v21/</guid><description>The following announcements are specific to Version 21.x. For information presented chronologically, see News.
Python Updates We made some changes in Python language support in Protocol Buffers. Version 4.21.0 is a new major version, following 3.20.1. The new version is based on the upb library, and offers significantly better parsing performance than previous releases, especially for large payloads. It also includes prebuilt binary modules for Apple silicon for increased performance without a manual build.</description></item><item><title>News Announcements for Version 22.x</title><link>https://protobuf.dev/news/v22/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/v22/</guid><description>The following announcements are specific to Version 22.x. For information presented chronologically, see News.
Changing Maven Release Candidate Artifact Names to Be More Idiomatic In 22.0 we plan to rename Maven artifacts to use “RC” instead of “rc-” as the release candidate prefix.
Adding an Abseil Dependency In order to reduce the Google vs. OSS differences between protobuf and to simplify our own project, we plan to take a formal dependency on Abseil.</description></item><item><title>News Announcements for Version 23.x</title><link>https://protobuf.dev/news/v23/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/v23/</guid><description>The following announcements are specific to Version 23.x. For information presented chronologically, see News.
Changes to Ruby Generator This GitHub PR, which will appear in the 23.x release, changes the Ruby code generator to emit a serialized proto instead of the DSL.
It removes the DSL from the code generator in anticipation of splitting the DSL out into a separate package.
Given a .proto file like:
syntax = &amp;#34;proto3&amp;#34;; package pkg; message TestMessage { optional int32 i32 = 1; optional TestMessage msg = 2; } Generated code before:</description></item><item><title>News Announcements for Version 24.x</title><link>https://protobuf.dev/news/v24/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/v24/</guid><description>The following announcements are specific to Version 24.x. For information presented chronologically, see News.
Stricter validation for json_name v24 will forbid embedded null characters in the json_name field option. Going forward, any valid Unicode characters will be accepted, except \u0000. Null will still be allowed in field values.
Previously, the proto compiler allowed null characters, but support for this was inconsistent across languages and implementations. To fix this, we are clarifying the spec to say that null is not allowed in json_name, and will be rejected by the compiler.</description></item><item><title>News Announcements for Version 25.x</title><link>https://protobuf.dev/news/v25/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/v25/</guid><description>The following announcements are specific to Version 25.x. For information presented chronologically, see News.
Python Breaking Change In v25 message.UnknownFields() will be deprecated in pure Python and C++ extensions. It will be removed in v26. Use the new UnknownFieldSet(message) support in unknown_fields.py as a replacement.
μpb Moving to the Protobuf Git Repository Starting with the v25 release, μpb now lives in the protobuf repo instead of in its former location in a separate repo.</description></item><item><title>News Announcements for Version 26.x</title><link>https://protobuf.dev/news/v26/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/v26/</guid><description>The following announcements are specific to Version 26.x. For information presented chronologically, see News.
General Changes JSON Formatter Option Changes Starting in the 26.x line, the JSON formatter option to print default-valued fields is replaced with a fixed way to handle proto2 and proto3 optional fields consistently.
Java: includingDefaultValueFields() is replaced with alwaysPrintFieldsWithNoPresence(). C++: always_print_default_values is replaced with always_print_fields_with_no_presence=True. Py: including_default_value_fields=True is replaced with always_print_fields_with_no_presence=True. The new flag behaves identically to the old flag on proto3 messages, but no longer applies to proto2 optional fields.</description></item><item><title>News Announcements for Version 29.x</title><link>https://protobuf.dev/news/v29/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/v29/</guid><description>The following announcements are specific to Version 29.x. For information presented chronologically, see News.
Bazel and Proto Rules There are upcoming changes to the way that Bazel will work for protobuf builds. These changes require awareness in the first stage, and action by project owners before the second stage.
Stage 1 With the release of Bazel 8, proto rules (proto_library, cc_proto_library, java_proto_library, java_lite_proto_library, and py_proto_library) will be removed from the Bazel project.</description></item><item><title>News Announcements for Version 30.x</title><link>https://protobuf.dev/news/v30/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/v30/</guid><description>The following announcements are specific to Version 30.x. For information presented chronologically, see News.
The following sections cover planned breaking changes in the v30 release, expected in 2025 Q1. Also included are some changes that aren&amp;rsquo;t breaking but may require action on your part. These describe changes as we anticipate them being implemented, but due to the flexible nature of software some of these changes may not land or may vary from how they are described in this topic.</description></item><item><title>News Announcements for Version 31.x</title><link>https://protobuf.dev/news/v31/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://protobuf.dev/news/v31/</guid><description>The following announcements are specific to Version 31.x. For information presented chronologically, see News.
The following sections cover planned breaking changes in the v31 release, expected in 2025 Q2. Also included are some changes that aren&amp;rsquo;t breaking but may require action on your part. These describe changes as we anticipate them being implemented, but due to the flexible nature of software some of these changes may not land or may vary from how they are described in this topic.</description></item></channel></rss>